---
slug: graphql-vs-rest
title: "I reviewed 1,000s of GraphQL vs. REST discussions"
authors: dylan
tags: [API]
image: ./graphql-vs-rest-assets/discussion-funnel.png
---

{/* <Admonition type="danger" title="Strong Opinions incoming!">

This post highlights opinions with heavy vulgar ðŸ˜³

</Admonition>

Ask any developer, do you prefer GraphQL or REST? It will likely spark an
opinionated conversation which can often devolve into vulgar opinions instead of
matter-of-facts. Developers often find themselves entangled in discussions about
the merits of each approach, but like any engineering decision, **there are no
one-size-fits-all solutions**. This post aims to dissect the coexistence of
GraphQL and REST, highlighting the practical tradeoffs that shape this dynamic
landscape.

To be "sciency", I reviewed thousands of discussions on YouTube, Reddit, Hacker
News, and Blog Posts. I then collected, categorized, and analyzed the top
discussions.  Here are my findings.

<Admonition type="note">
**For this post, I wanted to make 100% sure that the tone of this article
is neutral and unbiased. I am not trying to promote one over the other. At
Konfig, we use GraphQL in our internal APIs but also build on the REST-focused
OpenAPI and standards.**
</Admonition>


## Briefly about GraphQL and REST

[GraphQL](https://graphql.org/) and
[REST](https://en.wikipedia.org/wiki/Representational_state_transfer) are two
different approaches to building APIs. GraphQL is a query language for APIs and
a runtime for fulfilling those queries with your existing data. REST is an
architectural style for building APIs. REST is not a standard, but rather a set
of constraints that define how the server and client should communicate. REST is
often implemented using HTTP.

*/}

To understand the GraphQL vs. REST debate, I went to the places where developers
like to discuss these sorts of topics: YouTube, Reddit, Twitter, and Hacker
News. I parsed thousands of discussions and organized my findings in this
article. I did my best to make sure only to curate thought-provoking
discussions.

<Figure caption='Funnel for gathering through-provoking discussions'>
![Discussion funnel](./graphql-vs-rest-assets/discussion-funnel.png)
</Figure>

I then took the discussions to a whiteboard, categorized them into "Pro GraphQL", "Pro REST", or "Neutral", and clustered them into perspectives. Each
section in this post will highlight a perspective along with the relevant
discussions. Finally, I chose to highlight blog posts from GitHub and Shopify
that serve as useful case studies in this debate.

<Figure caption={<div><a href="https://www.figma.com/figjam/">FigJam</a> I used to organize my discussion. Blue is "GraphQL", yellow is "REST", and green is "Neutral".</div>}>
![FigJam](./graphql-vs-rest-assets/figma-board.png)
</Figure>

## Neutral

To start, I think it's important to highlight the neutral discussions. In my
opinion, these are the ones that hold the most truth in that they acknowledge
the tradeoffs of each approach. They are also the rarest opinions to find since
most developers are stubborn in their ways.

{/* TRUNCATE */}

### Perspective: GraphQL is great for some use cases, but not all

<Carousel.Wrapper>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://www.youtube.com/watch?v=eIQh02xuVw4">YouTube</a></span>}>
            ![neutral 2](./graphql-vs-rest-assets/slides/after/neutral-2.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/128xzeg/graphql_trending_down/">Reddit</a></span>}>
            ![neutral 1](./graphql-vs-rest-assets/slides/after/neutral-1.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/1509p4m/im_not_impressed_by_graphql_and_i_still_prefer/">Reddit</a></span>}>
            ![neutral 3](./graphql-vs-rest-assets/slides/after/neutral-90-percent.png)
        </Figure>
    </Carousel.Slide>
</Carousel.Wrapper>

#### Key Takeaway ðŸ”‘

GraphQL is great for highly relational data models and large teams with enormous scaling problems, but it's not a silver bullet.

GraphQL was born out of the need to solve a specific problem at Facebook.
Specifically [the migration of Facebook's newsfeed functionality from the web to
mobile](https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/).


Because Facebook has contributed [so many great projects to open
source](https://opensource.fb.com/), it's easy for engineers to blindly adopt
the latest and greatest from Facebook in hopes it will help you preemptively
solve scaling problems. But as always, you have to understand the problem you
are solving to make the right technical decision for your team or you risk
over-engineering your solution.

### Perspective: The benefits of GraphQL are great, but difficult to implement in practice

<Carousel.Wrapper>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=32366759">Hacker News</a></span>}>
            ![neutral everyone faster](./graphql-vs-rest-assets/slides/after/neutral-everyone-faster.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=25014582">Hacker News</a></span>}>
            ![neutral-joy-querying-rest-deterministic](./graphql-vs-rest-assets/slides/after/neutral-joy-querying-rest-deterministic.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=32366759">Hacker News</a></span>}>
            ![neutral-high-skill](./graphql-vs-rest-assets/slides/after/neutral-high-skill.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/128xzeg/graphql_trending_down/">Reddit</a></span>}>
            ![neutral-misunderstood](./graphql-vs-rest-assets/slides/after/neutral-misunderstood.png)
        </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
        <Figure caption={<span>Source: <a href="https://twitter.com/mattknox/status/1522641060341579776">Twitter</a></span>}>
            ![neutral-persisted-queries](./graphql-vs-rest-assets/slides/after/neutral-persisted-queries.png)
        </Figure>
    </Carousel.Slide>
</Carousel.Wrapper>

#### Key Takeaway ðŸ”‘

To successfully implement GraphQL at scale, a high level of skill is required to
ensure optimal performance.

In practice, GraphQL provides an exceptional
interface for frontend and API consumers, enabling them to query and explore the
API efficiently. However, it does shift a significant portion of complexity to
the backend. For instance, in the absence of [persisted
queries](https://www.apollographql.com/docs/apollo-server/performance/apq/),
GraphQL exposes an interface that can be potentially hazardous, allowing
unbounded query requests to your API. Have a public GraphQL API? Then you are forced to rate limit
by calculating [query complexity, like
Shopify](https://shopify.engineering/rate-limiting-graphql-apis-calculating-query-complexity).
Without access to skilled engineers and the resources for substantial
infrastructure investment, GraphQL can become a recipe for disaster when it
comes to scalability.

Nonetheless, when executed correctly, GraphQL can bring immense benefits to
client-heavy applications, offering tools like
[GraphiQL](https://github.com/graphql/graphiql) for interactive query
exploration, [cache normalization with
urql](https://formidable.com/open-source/urql/docs/) for efficient data
management, and the ability to create granular queries without much hassle.
Without GraphQL, incorporating these features would demand a significant amount
of effort.

On the other hand, REST doesn't share these scalability challenges to the same
extent, as backend developers can pinpoint performance issues to specific
endpoints. Developers can also rely on the mature and well-defined HTTP
specification that existing infrastructure is already equipped to handle.

## Pro REST

REST APIs have been around for decades. Much of the world's networking
infrastructure is built on the HTTP standard, so it's no surprise that REST
enjoys substantial support. However, similar to how
[SOAP](https://en.wikipedia.org/wiki/SOAP) was eventually [overtaken by
REST](https://stackify.com/soap-vs-rest/#:~:text=SOAP%20was%20long%20the%20standard,primary%20differences%20between%20SOAP%20vs.),
GraphQL now poses a challenge to REST. As with any technological shift, there
will always be those who express skepticism.

### Perspective: GraphQL is not worth the complication

<Carousel.Wrapper>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/13z6amn/what_are_some_harsh_truths_that_rwebdev_needs_to/">Reddit</a></span>}>
    ![rest-blog](./graphql-vs-rest-assets/slides/after/rest-blog.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=32366759">Hacker News</a></span>}>
    ![rest-access-control](./graphql-vs-rest-assets/slides/after/rest-access-control.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.youtube.com/watch?v=PTfZcN20fro">YouTube</a></span>}>
    ![rest-difficult-to-maintain](./graphql-vs-rest-assets/slides/after/rest-difficult-to-maintain.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.youtube.com/watch?v=yWzKJPw_VzM">YouTube</a></span>}>
    ![rest-footgun](./graphql-vs-rest-assets/slides/after/rest-footgun.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://twitter.com/jmhodges/status/1522385068974432256">Twitter</a></span>}>
    ![rest-sky-high-maintenance](./graphql-vs-rest-assets/slides/after/rest-sky-high-maintenance.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=32366759">Hacker News</a></span>}>
    ![rest-keep-graphql-dumb](./graphql-vs-rest-assets/slides/after/rest-keep-graphql-dumb.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.youtube.com/watch?v=yWzKJPw_VzM">YouTube</a></span>}>
    ![rest-knowledge-gap](./graphql-vs-rest-assets/slides/after/rest-knowledge-gap.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=25014582">Hacker News</a></span>}>
    ![rest-over-querying](./graphql-vs-rest-assets/slides/after/rest-over-querying.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/15i073y/i_need_to_get_this_off_my_chest/">Reddit</a></span>}>
    ![rest-overcomplicated](./graphql-vs-rest-assets/slides/after/rest-overcomplicated.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=32366759">Hacker News</a></span>}>
    ![rest-pain-to-use](./graphql-vs-rest-assets/slides/after/rest-pain-to-use.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://news.ycombinator.com/item?id=19147742">Hacker News</a></span>}>
    ![rest-patch-work](./graphql-vs-rest-assets/slides/after/rest-patch-work.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.reddit.com/r/webdev/comments/128xzeg/graphql_trending_down/">Reddit</a></span>}>
    ![rest-pretend](./graphql-vs-rest-assets/slides/after/rest-pretend.png)
    </Figure>
    </Carousel.Slide>
    <Carousel.Slide>
    <Figure caption={<span>Source: <a href="https://www.youtube.com/watch?v=PTfZcN20fro">YouTube</a></span>}>
    ![rest-unnecessary-complexity](./graphql-vs-rest-assets/slides/after/rest-unnecessary-complexity.png)
    </Figure>
    </Carousel.Slide>
</Carousel.Wrapper>

#### Key Takeaway ðŸ”‘

GraphQL is over-complicated.

The complexity that you inherit by adopting GraphQL makes its benefits simply
not worth it for most engineering teams. Does your organization have millions of
dollars of engineers on payroll? Is your data model extremely relational? Is
your API reaching millions of users? If not, you probably shouldn't be adopting
GraphQL for its flexible query language.

Features that are simple to implement with REST instantly become a huge pain with GraphQL:

- Access control
- Rate limiting
- Caching
- Knowledge sharing
- [DOS](https://en.wikipedia.org/wiki/Denial-of-service_attack) protection
- Using Maps/Tables/Dictionaries
- [N + 1 Problem](https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping)

Not to mention the fact that GraphQL is a new technology you need to educate your team about.

### Perspective: GraphQL is not performant

## Pro GraphQL

### Perspective: GraphQL has an amazing developer experience

### Perspective: GraphQL benefits only appear in the largest organizations

This is admittedly more an observation than a perspective shared in discussions,
but I think it's worth noting. You can't ignore the use of GraphQL in hyper-scale
organizations like Facebook, GitHub, and Shopify.

## My Perspective

In most cases, for GraphQL to effectively address the problems it was originally
designed to solve, a team should ideally possess a considerable number of
developers, and their API should handle traffic at a "unicorn scale." However,
unless you are currently building a unicorn-level project, it may not be
necessary to overly concern yourself with such extensive scalability, as the
complexity involved might not be justified. Notable giants like Twilio and
Stripe, for instance, have not yet integrated GraphQL into their public APIs
despite being well beyond unicorn status.

Nevertheless, if you have a workflow that takes advantage of the remarkable
developer experience offered by GraphQL, then by all means, embrace it! Just
ensure that you are fully aware of the tradeoffs involved. Ultimately, the most
suitable choice for smaller companies is whatever enables faster development.
export const snapTradeGettingStartedMarkdown = `### 1) Initialize a client with your clientId and consumerKey

You can get your \`clientId\` and \`consumerKey\` by contacting [api@snaptrade.com](mailto:api@snaptrade.com)

:::form

::input{name=SNAPTRADE_CLIENT_ID label="Client ID" placeholder="YOUR_CLIENT_ID" type="password"}

::input{name=SNAPTRADE_CONSUMER_KEY label="Consumer Key" placeholder="YOUR_CONSUMER_KEY" type="password"}

\`\`\`python
from snaptrade_client import SnapTrade
from pprint import pprint
import uuid
import os

snaptrade = SnapTrade(
  consumer_key=SNAPTRADE_CONSUMER_KEY,
  client_id=SNAPTRADE_CLIENT_ID,
)

print("Successfully initiated client")
\`\`\`


::button[Initialize SDK Client]

:::

### 2) Check that the client is able to make a request to the API server

Call the API Status endpoint to make sure the API is live and that you can make
the most basic request. You should receive a response indicating the API status,
current server timestamp, and internal API minor version number.

:::form

\`\`\`python
api_response = snaptrade.api_status.check()
pprint(api_response.body)
\`\`\`

::button[Check API Status]

:::

### 3) Create a new user on SnapTrade

To create a secure brokerage authorization, we first need to register a test
user. Call the Register user endpoint with a userId which can be any string as
long as it's unique to a user. Upon receiving a 200 response, the user is
registered successfully and you should receive a response with a user id and a
randomly generated user secret. You can think of the user secret like a per-user
API key that provides an additional layer of security for protecting user data.
The user id and user secret need to be passed along to all SnapTrade API
endpoints that involve access to user data.

:::form

::input{name=SNAPTRADE_USER_ID label="SnapTrade User ID" placeholder="YOUR_SNAPTRADE_USER_ID" type="password"}

\`\`\`python
user_id = SNAPTRADE_USER_ID
register_response = snaptrade.authentication.register_snap_trade_user(
    user_id=user_id
)
pprint(register_response.body)

# Note: A user secret is only generated once. It's required to access
# resources for certain endpoints.
user_secret = register_response.body["userSecret"]
\`\`\`

::button[Create a new user on SnapTrade]

:::

### 4) Get a redirect URI

SnapTrade partners need to generate a redirect URI for a user so they can
securely log in to the SnapTrade Connection portal and connect their accounts.
The redirect URI can be generated by sending a POST request to the Login
endpoint. userId and userSecret (previously generated through calling the
registerUser endpoint) have to be in the query parameters of the POST request.
The response would indicate a redirectURI to be used for login a user to the
SnapTrade portal.

:::form

\`\`\`python
redirect_uri = snaptrade.authentication.login_snap_trade_user(
  user_id=user_id, user_secret=user_secret
)

print(redirect_uri.body["redirectURI"])
\`\`\`

::button[Get Redirect URI]

:::

### 5) Get account holdings data

In order to retrieve user holdings for a specific account, you can call the
Holdings endpoint by passing the clientId, timestamp, userId and list of account
numbers (accounts) to filter the holdings. In the response, you should get an
array of objects containing each account holdings data.


:::form
\`\`\`python
holdings = snaptrade.account_information.get_all_user_holdings(
  user_id=user_id, user_secret=user_secret
)
pprint(holdings.body)
\`\`\`

::button[Get Account Holdings]

:::

### 6) Deleting a user

Disabling all brokerage authorizations and permanently deleting all data
associated with the user


:::form
\`\`\`python
deleted_response = snaptrade.authentication.delete_snap_trade_user(
  user_id=user_id
)
pprint(deleted_response.body)
\`\`\`

::button[Delete User]

:::
`;

export const snapTradeRegisteringUsersMarkdown = `### 1) Initialize a client with your clientId and consumerKey

You can get your \`clientId\` and \`consumerKey\` by contacting [api@snaptrade.com](mailto:api@snaptrade.com)

:::form

::input{name=SNAPTRADE_CLIENT_ID label="Client ID" placeholder="YOUR_CLIENT_ID" type="password"}

::input{name=SNAPTRADE_CONSUMER_KEY label="Consumer Key" placeholder="YOUR_CONSUMER_KEY" type="password"}

\`\`\`python
from snaptrade_client import SnapTrade
from pprint import pprint
import uuid
import os

snaptrade = SnapTrade(
  consumer_key=SNAPTRADE_CONSUMER_KEY,
  client_id=SNAPTRADE_CLIENT_ID,
)

print("Successfully initiated client")
\`\`\`


::button[Initialize SDK Client]

:::

### 2) Check that the client is able to make a request to the API server

Call the API Status endpoint to make sure the API is live and that you can make
the most basic request. You should receive a response indicating the API status,
current server timestamp, and internal API minor version number.

:::form

\`\`\`python
api_response = snaptrade.api_status.check()
pprint(api_response.body)
\`\`\`

::button[Check API Status]

:::

### 3) Register User

To create a secure brokerage authorization, we first need to register a test
user. Call the Register user endpoint with a userId which can be any string as
long as it's unique to a user. Upon receiving a 200 response, the user is
registered successfully and you should receive a response with a user id and a
randomly generated user secret. You can think of the user secret like a per-user
API key that provides an additional layer of security for protecting user data.
The user id and user secret need to be passed along to all SnapTrade API
endpoints that involve access to user data.

:::form

::input{name=SNAPTRADE_USER_ID label="SnapTrade User ID" placeholder="YOUR_SNAPTRADE_USER_ID" type="password"}

\`\`\`python
user_id = SNAPTRADE_USER_ID
register_response = snaptrade.authentication.register_snap_trade_user(
    user_id=user_id
)
pprint(register_response.body)

# Note: A user secret is only generated once. It's required to access
# resources for certain endpoints.
user_secret = register_response.body["userSecret"]
\`\`\`

::button[Create a new user on SnapTrade]

:::

### 4) Login User

SnapTrade partners need to generate a redirect URI for a user so they can
securely log in to the SnapTrade Connection portal and connect their accounts.
The redirect URI can be generated by sending a POST request to the Login
endpoint. userId and userSecret (previously generated through calling the
registerUser endpoint) have to be in the query parameters of the POST request.
The response would indicate a redirectURI to be used for login a user to the
SnapTrade portal.

:::form

\`\`\`python
redirect_uri = snaptrade.authentication.login_snap_trade_user(
  user_id=user_id, user_secret=user_secret
)

print(redirect_uri.body["redirectURI"])
\`\`\`

::button[Login User]

:::

### 5) List Users


:::form
\`\`\`python
users = snaptrade.authentication.list_snap_trade_users()
pprint(users.body)
\`\`\`

::button[List Users]

:::

### 6) Deleting a user

Disabling all brokerage authorizations and permanently deleting all data
associated with the user

:::form
\`\`\`python
deleted_response = snaptrade.authentication.delete_snap_trade_user(
  user_id=user_id
)
pprint(deleted_response.body)
\`\`\`

::button[Delete User]

:::
`;

export const snapTradeHandlingUserDataMarkdown = `
:::info
This demo is for after a user is created and connected. See [Getting Started](/snaptrade/snaptrade-demos/getting-started) or
[Registering Users](/snaptrade/snaptrade-demos/registering-users) for creating and connecting a user to SnapTrade.
:::

### 1) Initialize a client with your clientId and consumerKey

You can get your \`clientId\` and \`consumerKey\` by contacting [api@snaptrade.com](mailto:api@snaptrade.com)

:::form

::input{name=SNAPTRADE_CLIENT_ID label="Client ID" placeholder="YOUR_CLIENT_ID" type="password"}

::input{name=SNAPTRADE_CONSUMER_KEY label="Consumer Key" placeholder="YOUR_CONSUMER_KEY" type="password"}

\`\`\`python
from snaptrade_client import SnapTrade
from pprint import pprint
import uuid
import os

snaptrade = SnapTrade(
  consumer_key=SNAPTRADE_CONSUMER_KEY,
  client_id=SNAPTRADE_CLIENT_ID,
)

print("Successfully initiated client")
\`\`\`


::button[Initialize SDK Client]

:::

### 2) Get all user holdings

List all accounts for the user, plus balances and positions for each account.

:::form

::input{name=USER_ID label="User ID" placeholder="YOUR_USER_ID" type="password"}

::input{name=USER_SECRET label="User Secret" placeholder="YOUR_USER_SECRET" type="password"}

\`\`\`python
user_id = USER_ID
user_secret = USER_SECRET
holdings = snaptrade.account_information.get_all_user_holdings(
  user_id=USER_ID, user_secret=user_secret
)
pprint(holdings.body)
\`\`\`

::button[Get all user holdings]

:::

### 3) Get Transactions / Historical Activities

Returns activities (transactions) for a user. Specifying start and end date is
highly recommended for automatic calls for better performance. This uses the
TransactionsAndReporting API.

:::form

::date{name=START_DATE label="Start Date" placeholder="START_DATE" valueFormat="YYYY-MM-DD" optional}
::date{name=END_DATE label="End Date" placeholder="END_DATE" valueFormat="YYYY-MM-DD" optional}
::input{name=ACCOUNTS label="Account(s)" placeholder="YOUR_ACCOUNT_IDS" description="Optional comma seperated list of account IDs used to filter the request on specific accounts" optional}
::input{name=BROKERAGE_AUTHORIZATIONS label="Brokerage Authorizations" placeholder="YOUR_BROKERAGE_AUTHORIZATION" description="Optional comma seperated list of brokerage authorization IDs used to filter the request on only accounts that belong to those authorizations" optional}
::input{name=TYPE label="Type" placeholder="DIVIDEND" description="Optional comma seperated list of types to filter activities by" optional}


\`\`\`python
activities = snaptrade.transactions_and_reporting.get_activities(
  user_id=user_id,
  user_secret=user_secret,
  start_date=START_DATE if "START_DATE" in globals() else None,
  end_date=END_DATE if "END_DATE" in globals() else None,
  accounts=ACCOUNTS if "ACCOUNTS" in globals() else None,
  brokerage_authorizations=BROKERAGE_AUTHORIZATIONS if "BROKERAGE_AUTHORIZATIONS" in globals() else None,
  type=TYPE if "TYPE" in globals() else None
)
pprint(activities.body)
\`\`\`

::button[Get Activities]

:::

### 4) Get Quotes

Get symbol quotes for a user, these are account and thus brokerage specific.
That means if you have a US only account, you cannot get quotes for
international exchanges. This uses the Trading API.

:::form

::input{name=SYMBOLS label="Symbols" placeholder="AAPL" description="List of universal_symbol_id or tickers to get quotes for"}
::input{name=ACCOUNT_ID label="Account ID" placeholder="ACCOUNT ID" description="The ID of the account to get quotes"}
::input{name=USE_TICKER type="checkbox" defaultValue=true label="Use Ticker" description="Should be set to True if providing tickers" optional}


\`\`\`python
activities = snaptrade.trading.get_user_account_quotes(
  user_id=user_id,
  user_secret=user_secret,
  symbols=SYMBOLS,
  account_id=ACCOUNT_ID,
  use_ticker=USE_TICKER if "USE_TICKER" in globals() else None,
)
pprint(activities.body)
\`\`\`

::button[Get Activities]

:::
`;

export const snapTradePlacingTradesMarkdown = `
:::info
This demo is for after a user is created and connected. See [Getting Started](/snaptrade/snaptrade-demos/getting-started) or
[Registering Users](/snaptrade/snaptrade-demos/registering-users) for creating and connecting a user to SnapTrade.
:::

### 1) Initialize a client with your clientId and consumerKey / assign \`user_id\` and \`user_secret\` to variables

You can get your \`clientId\` and \`consumerKey\` by contacting [api@snaptrade.com](mailto:api@snaptrade.com)

:::form

::input{name=SNAPTRADE_CLIENT_ID label="Client ID" placeholder="YOUR_CLIENT_ID" type="password"}

::input{name=SNAPTRADE_CONSUMER_KEY label="Consumer Key" placeholder="YOUR_CONSUMER_KEY" type="password"}

::input{name=USER_ID label="User ID" placeholder="YOUR_USER_ID" type="password"}

::input{name=USER_SECRET label="User Secret" placeholder="YOUR_USER_SECRET" type="password"}

\`\`\`python
from snaptrade_client import SnapTrade
from pprint import pprint
import uuid
import os

snaptrade = SnapTrade(
  consumer_key=SNAPTRADE_CONSUMER_KEY,
  client_id=SNAPTRADE_CLIENT_ID,
)

print("Successfully initiated client")

user_id = USER_ID
user_secret = USER_SECRET

print("Initialized user_id and user_secret")
\`\`\`


::button[Initialize SDK Client / Assign Variables]

:::

### 2) Get Order Impact

Check the account has enough cash to place trades.


:::form

::input{name=ACCOUNT_ID label="Account ID" placeholder="ACCOUNT ID" description="The ID of the account to check"}
::input{name=UNIVERSAL_SYMBOL label="Universal Symbol" defaultValue="c15a817e-7171-4940-9ae7-f7b4a95408ee"}
::input{name=ACTION label="Action" defaultValue="BUY"}
::input{name=ORDER_TYPE label="Order Type" defaultValue="Limit"}
::input{name=TIME_IN_FORCE label="Time in Force" defaultValue="Day"}
::number{name=PRICE label="Price" defaultValue=10, step=0.01 precision=2}
::number{name=UNITS label="Units" defaultValue=1}

\`\`\`python
result = snaptrade.trading.get_order_impact(
  user_id=user_id,
  user_secret=user_secret,
  action=ACTION,
  account_id=ACCOUNT_ID,
  universal_symbol_id=UNIVERSAL_SYMBOL,
  order_type=ORDER_TYPE,
  time_in_force=TIME_IN_FORCE,
  price=PRICE,
  units=UNITS,
)
pprint(result.body)
\`\`\`

::button[Get Order Impact]

:::

### 3) Place Force Order

Place the order without checking impact

:::form

::input{name=ACCOUNT_ID label="Account ID" placeholder="ACCOUNT ID" description="The ID of the account to check"}
::input{name=UNIVERSAL_SYMBOL label="Universal Symbol" defaultValue="c15a817e-7171-4940-9ae7-f7b4a95408ee"}
::input{name=ACTION label="Action" defaultValue="BUY"}
::input{name=ORDER_TYPE label="Order Type" defaultValue="Limit"}
::input{name=TIME_IN_FORCE label="Time in Force" defaultValue="Day"}
::number{name=PRICE label="Price" defaultValue=10, step=0.01 precision=2}
::number{name=UNITS label="Units" defaultValue=1}

\`\`\`python
result = snaptrade.trading.place_force_order(
  user_id=user_id,
  user_secret=user_secret,
  action=ACTION,
  account_id=ACCOUNT_ID,
  universal_symbol_id=UNIVERSAL_SYMBOL,
  order_type=ORDER_TYPE,
  time_in_force=TIME_IN_FORCE,
  price=PRICE,
  units=UNITS,
)
pprint(result.body)
\`\`\`

::button[Place Force Order]

:::

`;

const humanloopGettingStarted = `### Setup: Initialize SDK

:::info{title="This is an interactive demo"}
To show the source code of the demo, click \`Show Code\` in the top-right. You
can run in each step by providing your own values and clicking buttons. To run
this demo locally you can install Humanloop's Python SDK by running \`pip
install humanloop\` and paste the code into your own editor any replacing
variables with your own values.
:::

:::info{title="Using other model providers"}
This guide assumes you're using an [OpenAI](https://openai.com/). If you want to use other
providers or your own model please also look at our [guide to using your own
model](https://docs.humanloop.com/docs/use-your-own-model-provider).
:::



Signup for your Humanloop API key [here](https://app.humanloop.com/signup) and pass
in your API key from OpenAI.

:::form

::input{name=HUMANLOOP_API_KEY label="Humanloop API Key" placeholder="YOUR_HUMANLOOP_API_KEY" type="password"}
::input{name=OPENAI_API_KEY label="OpenAI API Key" placeholder="YOUR_OPENAI_API_KEY" type=password}

\`\`\`python
from pprint import pprint
from humanloop import Humanloop

humanloop = Humanloop(
  host="https://neostaging.humanloop.ml/v4",
  api_key=HUMANLOOP_API_KEY,
  openai_api_key=OPENAI_API_KEY,
)

print("Initialized Client")
\`\`\`

::button[Initialize Client]

:::

### 1) Create a Project

The Humanloop Python SDK allows you to programmatically set up Humanloop
projects with [model
configs](https://docs.humanloop.com/docs/key-concepts#model-config) and a
[feedback schema](https://docs.humanloop.com/docs/key-concepts#feedback).

:::form

::input{name=PROJECT_NAME label="Project Name" placeholder="My Project"}

\`\`\`python
project_name = "{}-sdk-tutorial".format(PROJECT_NAME)
project_response = humanloop.projects.create(name=project_name)
project_id = project_response.body["id"]
pprint(project_response.body)
\`\`\`

::button[Create Project]

:::


### 2) Add your own feedback types and values

By default your project has a feedback type \`rating\` with labels \`good\` and \`bad\`.

:::form

\`\`\`python
response = humanloop.projects.update_feedback_types(
  id=project_id,
  body=[{
      "type": "action",
      "class": "multi_select",
      "values": [
        {"value": "copied"}, {"value": "saved"}
      ],
  }]
)
pprint(response.body)
\`\`\`

::button[Add Feedback Type]

:::

### 3) Register your Model Config

You can register a model configuration with a specified model and prompt
template. In this case we are using \`gpt-3.5-turbo\` and \`"Write a snappy
introduction about {{topic}}:"\`. By using double curly braces such as
\`{{topic}}\`, we allow the model to accept the \`topic\` input to be later used
in step 5.

:::form

\`\`\`python
model_config = humanloop.model_configurations.register(
  project=project_name,
  model="gpt-3.5-turbo",
  prompt_template="Write a snappy introduction about {{topic}}:",
  temperature=0.8,
)
config_id = model_config.body["config"]["id"]
pprint(model_config.body)
\`\`\`

::button[Register Model Config]

:::

### 4) Activate Model Config

:::info{title="Ensure that there is an active deployment"}

See
[here](https://docs.humanloop.com/docs/completion-using-the-sdk#activate-a-model)
for instructions on how to ensure there is an active deployment in the dashboard.

:::

:::form

\`\`\`python
print("Setting active config for project with id:", project_id)
print("Setting active config id to:", config_id)
project = humanloop.projects.update(id=project_id, active_config_id=config_id)
pprint(project.body)
\`\`\`

::button[Activate Model Config]
:::

### 5) Generate Completions


Now we can call the active model config on your project. The inputs must match the input of the prompt template in your project.

:::form

::input{name=TOPIC label="Topic" placeholder="Pickleball" description="Choose a description from the template we registered earlier"}

\`\`\`python
print("Generating completion for project: ", project_name)
print("Generating completion with topic: ", TOPIC)
complete_response = humanloop.complete_deployed(
    project=project_name,
    inputs={"topic": TOPIC},
)

# A single call to generate may return multiple outputs.
data_id = complete_response.body["data"][0]["id"]
print("data_id: ", data_id)
output = complete_response.body["data"][0]["output"]
print("output: ", output)

# You can also access the raw response from OpenAI.
pprint(complete_response.body["provider_responses"])
\`\`\`

::button[Generate Completion]

:::

Navigate to your project's **Data** tab in the browser to see the recorded
inputs and outputs of your generation.

Now that you have generations flowing through your project you can start to log
your end user feedback to evaluate and improve your models. Now that we have
made a generation, we can capture user feedback.

You can record feedback on generations from your users using the Humanloop
Python SDK. This allows you to monitor how your generations perform with your
users.

### 7) Record feedback with the datapoint ID

Call \`humanloop.feedback()\` referencing the saved datapoint ID to record user
feedback. You can provide a \`good\` or \`bad\` rating type feedback that is
default to every project and custom feedback types in your project. In this case
we will record either a \`good\` or \`bad\` rating feedback and a \`copied\`
value for \`action\` type feedback.

:::form

::input{name=RATING type="checkbox" defaultValue=true label="Rating" description="Checked for 'good' and unchecked for 'bad'"}

\`\`\`python
rating = "good" if RATING else "bad"
print("Recording feedback of:", rating)
humanloop.feedback(data_id=data_id, type="rating", value=rating)

# You can capture your own feedback type
humanloop.feedback(data_id=data_id, type="action", value="copied")
\`\`\`

::button[Record feedback]
:::

The feedback recorded for each datapoint can be viewed in the **Data** tab of your project.

Different use cases and user interfaces may require different kinds of feedback
that need to be mapped to the appropriate end user interaction. There are
broadly 3 important kinds of feedback:

1. **Explicit feedback**: these are purposeful actions to review the generations. For example, 'thumbs up/down' button presses.
2. **Implicit feedback**: indirect actions taken by your users may signal whether the generation was good or bad, for example, whether the user 'copied' the generation, 'saved it' or 'dismissed it' (which is negative feedback).
3. **Free-form feedback**: Corrections and explanations provided by the end-user on the generation.


### 8) Recording corrections as feedback

It can also be useful to allow your users to correct the outputs of your model.
This is strong feedback signal and can also be considered as ground truth data
for finetuning later.

:::form

::input{name=CORRECTION label="Correction" placeholder="A user provided completion..."}

\`\`\`python
# You can capture text based feedback to record corrections
humanloop.feedback(data_id=data_id, type="correction", value=CORRECTION)
\`\`\`

::button[Record correction]

:::

This feedback will also show up within Humanloop, where your internal users can
also provide feedback and corrections on logged data to help with evaluation.

`;

export type Demo = {
  id: string;
  name: string;
  markdown: string;
};
export type Portal = {
  id: string;
  portalName: string;
  demos: Demo[];
};
export type Organization = {
  id: string;
  organizationName: string;
  portals: Portal[];
};

export const demos: Organization[] = [
  {
    id: "snaptrade",
    organizationName: "SnapTrade",
    portals: [
      {
        id: "snaptrade-demos",
        portalName: "SnapTrade Demos",
        demos: [
          {
            id: "getting-started",
            name: "Getting Started",
            markdown: snapTradeGettingStartedMarkdown,
          },
          {
            id: "registering-users",
            name: "Registering Users",
            markdown: snapTradeRegisteringUsersMarkdown,
          },
          {
            id: "handling-user-data",
            name: "Handling User Data",
            markdown: snapTradeHandlingUserDataMarkdown,
          },
          {
            id: "placing-trades",
            name: "Placing Trades",
            markdown: snapTradePlacingTradesMarkdown,
          },
        ],
      },
    ],
  },
  {
    id: "humanloop",
    organizationName: "Humanloop",
    portals: [
      {
        id: "demos",
        portalName: "Humanloop Demo",
        demos: [
          {
            id: "getting-started",
            name: "Getting Started",
            markdown: humanloopGettingStarted,
          },
        ],
      },
    ],
  },
];

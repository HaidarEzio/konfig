{
  "openapi": "3.0.2",
  "info": {
    "title": "Humanloop API",
    "description": "The Humanloop API allows you to interact with Humanloop from your product or service.\n\nYou can do this through HTTP requests from any language or via our official Python SDK.\n\nTo install the official Python SDK, run the following command:\n\n```bash\npip install humanloop\n```\n\n---\n\nGuides and further details about key concepts can be found in [our docs](https://humanloop.gitbook.io/humanloop-docs/).",
    "version": "3.0.0",
    "x-konfig-ignore": {
      "object-with-no-properties": true
    }
  },
  "servers": [
    {
      "description": "Production server",
      "url": "https://api.humanloop.com/v3"
    }
  ],
  "tags": [
    {
      "name": "Projects"
    },
    {
      "name": "Organizations"
    },
    {
      "name": "Experiments"
    },
    {
      "name": "Metrics"
    },
    {
      "name": "Model configs"
    },
    {
      "name": "Generate"
    },
    {
      "name": "Logs"
    },
    {
      "name": "Feedback"
    },
    {
      "name": "Tools"
    },
    {
      "description": "The Humanloop API uses API keys for authentication. Visit your \n[User Settings](https://app.humanloop.com/llama/settings) page to retrieve the\nAPI key you'll use in your requests.\n\nThis key allows full access and control over your projects, so keep this secret\nand take care to not expose it in any client-side code.\n\nTo use your API key, include it under the `X-API-KEY` header in your HTTP request.\n\n```bash\ncurl https://api.humanloop.com/v3/projects -H 'X-API-KEY: YOUR_API_KEY'\n```\n\nIf you're using the Python SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```python\nhl.init(api_key=\"YOUR_API_KEY\")\n```",
      "name": "Authentication"
    }
  ],
  "paths": {
    "/projects": {
      "get": {
        "tags": ["Projects"],
        "summary": "Get Projects",
        "operationId": "Projects_list",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Retrieve a paginated list of projects associated to your user.",
        "parameters": [
          {
            "description": "Page offset for pagination.",
            "required": false,
            "schema": {
              "title": "Page index",
              "description": "Page offset for pagination.",
              "type": "integer",
              "default": 0
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Page size for pagination. Number of projects to fetch.",
            "required": false,
            "schema": {
              "title": "Page size",
              "description": "Page size for pagination. Number of projects to fetch.",
              "type": "integer",
              "default": 10
            },
            "name": "size",
            "in": "query"
          },
          {
            "description": "ID of organization that fetched projects belong to. Starts with `org_`.",
            "required": false,
            "schema": {
              "title": "Organization filter",
              "description": "ID of organization that fetched projects belong to. Starts with `org_`.",
              "type": "string"
            },
            "name": "organization_id",
            "in": "query"
          },
          {
            "description": "Case-insensitive filter for project name.",
            "required": false,
            "schema": {
              "title": "Project name filter",
              "description": "Case-insensitive filter for project name.",
              "type": "string"
            },
            "name": "filter",
            "in": "query"
          },
          {
            "description": "Case-insensitive filter for users in the project. This filter matches against both email address and name of users.",
            "required": false,
            "schema": {
              "title": "User filter",
              "description": "Case-insensitive filter for users in the project. This filter matches against both email address and name of users.",
              "type": "string"
            },
            "name": "user_filter",
            "in": "query"
          },
          {
            "description": "Field to sort projects by",
            "required": false,
            "schema": {
              "title": "Sort by",
              "description": "Field to sort projects by",
              "allOf": [
                {
                  "$ref": "#/components/schemas/ProjectSortBy"
                }
              ],
              "default": "created_at"
            },
            "name": "sort_by",
            "in": "query"
          },
          {
            "description": "Direction to sort by.",
            "required": false,
            "schema": {
              "title": "Sort order",
              "description": "Direction to sort by.",
              "allOf": [
                {
                  "$ref": "#/components/schemas/SortOrder"
                }
              ],
              "default": "desc"
            },
            "name": "order",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_ProjectResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Projects"],
        "summary": "Create Project",
        "operationId": "Projects_create",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Creates a new project with the provided name.\n\nAn error will be raised if the user is already associated to a project with\nthat name.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateProjectRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}": {
      "get": {
        "tags": ["Projects"],
        "summary": "Get Project",
        "operationId": "Projects_get",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["Projects"],
        "summary": "Update Project",
        "operationId": "Projects_update",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update the project with the specified ID.\n\nSet the project's active model config/experiment by passing either\n`active_experiment_id` or `active_model_config_id`.\n\nSet the feedback labels to be treated as positive user feedback used in\ncalculating top-level project metrics by passing a list of labels in\n`positive_labels`.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProjectRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/model-configs": {
      "get": {
        "tags": ["Projects"],
        "summary": "Get Project Model Configs",
        "operationId": "Projects_getModelConfigs",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get an array of model_configs associated to your project",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelConfigsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/model-config": {
      "get": {
        "tags": ["Projects"],
        "summary": "Get Model Config From Project",
        "operationId": "Projects_getModelConfig",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Retrieves a model config to use to execute your model.\n\nA model config will be selected based on the project's\nactive model config/experiment settings.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/active-model-config": {
      "delete": {
        "tags": ["Projects"],
        "summary": "Delete Active Model Config",
        "operationId": "Projects_deleteActiveModelConfig",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Remove the project's active model config, if set.\n\nThis has no effect if the project does not have an active model config set.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/active-experiment": {
      "delete": {
        "tags": ["Projects"],
        "summary": "Delete Active Experiment",
        "operationId": "Projects_deleteActiveExperiment",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Remove the project's active experiment, if set.\n\nThis has no effect if the project does not have an active experiment set.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/feedback-types": {
      "patch": {
        "tags": ["Projects"],
        "summary": "Update Feedback Types",
        "operationId": "Projects_updateFeedbackTypes",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update feedback types.\n\nAllows creation of the default feedback types and setting status of\nfeedback types/categorical values.\n\nThis behaves like an upsert; any feedback categorical values that do not\nalready exist in the project will be created.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateFeedbackTypesRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateFeedbackTypesResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{id}/export": {
      "post": {
        "tags": ["Projects"],
        "summary": "Export Datapoints",
        "operationId": "Projects_exportDatapoints",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Export all logged datapoints associated to your project.\n\nResults are paginated and sorts the datapoints based on `created_at` in\ndescending order.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Page offset for pagination.",
            "required": false,
            "schema": {
              "title": "Page index",
              "description": "Page offset for pagination.",
              "type": "integer",
              "default": 0
            },
            "name": "page",
            "in": "query"
          },
          {
            "description": "Page size for pagination. Number of logs to export.",
            "required": false,
            "schema": {
              "title": "Page size",
              "description": "Page size for pagination. Number of logs to export.",
              "type": "integer",
              "default": 10
            },
            "name": "size",
            "in": "query"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PaginatedData_LogResponse_"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/generate": {
      "post": {
        "tags": ["Generate"],
        "summary": "Generate",
        "operationId": "Generate_generate",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Generates an output from your model and automatically logs the results for feedback later.\n\nThe model config used for the generation depends on what parameters were specified. The 4 different behaviours, and the required parameters for each are listed below:\n\n1. `model_config`:\n    - The specific model config parameters will be used to link to an existing or create a new model config that will be used for this generation.\n    - E.g. `{ \"model_config\": { \"model: \"text-davinci-002\", \"prompt_template\", \"parameters\", ... } }`\n2. `model_config_id`:\n    - The ID of an existing model config to be used.\n    - E.g. `{ \"model_config_id\": \"config_abcdef1234567\" }`\n3. `experiment_id`:\n    - The ID of an existing experiment. A model config will be sampled from the experiment's list of active model configs.\n    - E.g. `{ \"experiment_id\": \"exp_abcdef1234567\" }`\n4. `project`:\n    - A model config will be selected based on the project's deployment settings.\n    - E.g. `{ \"project\": \"your-project-name-001\" }`\n\n\nThese signatures have been listed in decreasing priority. If multiple signatures are satisfied, the highest priority signature will be used.\nFor example, if both `model_config` and `experiment_id` are provided, the `model_config`  will be used and the `experiment_id` will be ignored.\n\n\nNote that all of the above signatures also require the following parameters: `project`, `inputs`, `source`, and `provider_api_keys`.\nAdditionally, the following parameters are supported: `num_samples`, `logprobs`, `suffix`, `user`, and `metadata`.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GenerateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GenerateResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/logs": {
      "post": {
        "tags": ["Logs"],
        "summary": "Log",
        "operationId": "Logs_log",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Log a datapoint or array of datapoints to your Humanloop project.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LogRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Log200Response"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/feedback": {
      "post": {
        "tags": ["Feedback"],
        "summary": "Feedback",
        "operationId": "Feedback_submit",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Submit a list of feedback for existing `data_ids`",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/SubmitRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SubmitResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/model-configs": {
      "post": {
        "tags": ["Model configs"],
        "summary": "Register Project Model Config",
        "operationId": "Modelconfigs_register",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Register a model config to a project and optionally add it to an\nexperiment.\n\nIf the project provided does not exist, a new project will be created\nautomatically.\nIf an experiment name is provided, the specified experiment must already\nexist. Otherwise, an error will be raised.\n\nIf the model config is the first to be associated to the project, it will\nbe set as the active model config.",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProjectModelConfigRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProjectModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/model-configs/{id}": {
      "get": {
        "tags": ["Model configs"],
        "summary": "Get Model Config",
        "operationId": "Modelconfigs_get",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "parameters": [
          {
            "description": "String ID of the model config. Starts with `config_`.",
            "required": true,
            "schema": {
              "title": "Model config ID",
              "description": "String ID of the model config. Starts with `config_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{project_id}/experiments": {
      "get": {
        "tags": ["Experiments"],
        "summary": "Get Project Experiments",
        "operationId": "Experiments_list",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get an array of experiments associated to your project.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Experiments"],
        "summary": "Create Project Experiment",
        "operationId": "Experiments_create",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Create an experiment for your project.\n\nYou can optionally specify IDs of your project's model configs to include\nin the experiment, along with a set of labels to consider as positive feedback\nand whether the experiment should be set as active.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/experiments/{experiment_id}": {
      "delete": {
        "tags": ["Experiments"],
        "summary": "Delete Experiment",
        "operationId": "Experiments_delete",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Delete the experiment with the specified ID.",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`.",
              "type": "string"
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["Experiments"],
        "summary": "Update Experiment",
        "operationId": "Experiments_update",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update your experiment, including registering and de-registering\nmodel configs.",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`.",
              "type": "string"
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateExperimentRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ExperimentResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/experiments/{experiment_id}/model-config": {
      "get": {
        "tags": ["Experiments"],
        "summary": "Get Model Config From Experiment",
        "operationId": "Experiments_getModelConfig",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Retrieves a model config to use to execute your model.\n\nA model config will be sampled from the experiment's list of active\nmodel configs.",
        "parameters": [
          {
            "description": "String ID of experiment. Starts with `exp_`.",
            "required": true,
            "schema": {
              "title": "Experiment ID",
              "description": "String ID of experiment. Starts with `exp_`.",
              "type": "string"
            },
            "name": "experiment_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetModelConfigResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{project_id}/metrics": {
      "get": {
        "tags": ["Metrics"],
        "summary": "Get Metrics",
        "operationId": "Metrics_list",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get an array of existing metrics for a given project.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/List200Response"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Metrics"],
        "summary": "Create Metric",
        "operationId": "Metrics_create",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Create a metric for your project.\n\nThe metric will be calculated for all datapoints in the project.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateMetricRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/projects/{project_id}/metrics/{metric_id}": {
      "delete": {
        "tags": ["Metrics"],
        "summary": "Delete Metric",
        "operationId": "Metrics_delete",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Delete a metric by its ID.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "description": "String ID of metric. Starts with `metric_`.",
            "required": true,
            "schema": {
              "title": "Metric ID",
              "description": "String ID of metric. Starts with `metric_`.",
              "type": "string"
            },
            "name": "metric_id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["Metrics"],
        "summary": "Update Metric",
        "operationId": "Metrics_update",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update a metric by its ID.",
        "parameters": [
          {
            "description": "String ID of project. Starts with `pr_`.",
            "required": true,
            "schema": {
              "title": "Project ID",
              "description": "String ID of project. Starts with `pr_`.",
              "type": "string"
            },
            "name": "project_id",
            "in": "path"
          },
          {
            "description": "String ID of metric. Starts with `metric_`.",
            "required": true,
            "schema": {
              "title": "Metric ID",
              "description": "String ID of metric. Starts with `metric_`.",
              "type": "string"
            },
            "name": "metric_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateMetricRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/MetricResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}": {
      "get": {
        "tags": ["Organizations"],
        "summary": "Get Organization",
        "operationId": "Organizations_get",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "patch": {
        "tags": ["Organizations"],
        "summary": "Update Organization",
        "operationId": "Organizations_update",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update the specified organization.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrganizationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/subscriptions": {
      "get": {
        "tags": ["Organizations"],
        "summary": "Get Organization Subscriptions",
        "operationId": "Organizations_getSubscriptions",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Fetches an organizations subscriptions.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSubscriptionsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/users/{user_id}/role": {
      "put": {
        "tags": ["Organizations"],
        "summary": "Update Organization User Role",
        "operationId": "Organizations_updateUserRole",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Updates a user's role in the specified organization.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "String ID of user. Starts with `usr_`.",
            "required": true,
            "schema": {
              "title": "User ID",
              "description": "String ID of user. Starts with `usr_`.",
              "type": "string"
            },
            "name": "user_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateUserOrganizationRole"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/users/{user_id}": {
      "delete": {
        "tags": ["Organizations"],
        "summary": "Remove User From Organization",
        "operationId": "Organizations_removeUser",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Removes a user from the specified organization.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "String ID of user. Starts with `usr_`.",
            "required": true,
            "schema": {
              "title": "User ID",
              "description": "String ID of user. Starts with `usr_`.",
              "type": "string"
            },
            "name": "user_id",
            "in": "path"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/api-keys": {
      "get": {
        "tags": ["Organizations"],
        "summary": "Get Api Keys",
        "operationId": "Organizations_getApiKeys",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get API keys for the organization.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetApiKeysResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/tools": {
      "get": {
        "tags": ["Organizations"],
        "summary": "Get Organization Tools",
        "operationId": "Organizations_getTools",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get all active tools for an organization.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetToolsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Organizations"],
        "summary": "Create Organization Tool",
        "operationId": "Organizations_createTool",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Create new organization tool with setup values.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrgToolRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationToolResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/organizations/{id}/tools/{tool_id}": {
      "patch": {
        "tags": ["Organizations"],
        "summary": "Update Organization Tool",
        "operationId": "Organizations_updateTool",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Update organization tool.",
        "parameters": [
          {
            "description": "String ID of organization. Starts with `org_`.",
            "required": true,
            "schema": {
              "title": "Organization ID",
              "description": "String ID of organization. Starts with `org_`.",
              "type": "string"
            },
            "name": "id",
            "in": "path"
          },
          {
            "description": "Unique ID of the organization's tool. Starts with `org_tool`.",
            "required": true,
            "schema": {
              "title": "Tool ID",
              "description": "Unique ID of the organization's tool. Starts with `org_tool`.",
              "type": "string"
            },
            "name": "tool_id",
            "in": "path"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateOrgToolRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/OrganizationToolResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tools": {
      "get": {
        "tags": ["Tools"],
        "summary": "Get Tool Specs",
        "operationId": "Tools_getSpecs",
        "security": [
          {
            "APIKeyHeader": []
          }
        ],
        "description": "Get all Humanloop provided tool specifications",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetSpecsResponse"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "ActiveSubscriptionResponse": {
        "title": "ActiveSubscriptionResponse",
        "required": ["id", "status", "created_at", "product", "interval"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/SubscriptionStatus"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "product": {
            "$ref": "#/components/schemas/ProductResponse"
          },
          "interval": {
            "$ref": "#/components/schemas/PaymentInterval"
          },
          "cancel_at_period_end": {
            "title": "Cancel At Period End",
            "type": "boolean"
          }
        }
      },
      "ApiKeyResponse": {
        "title": "ApiKeyResponse",
        "required": [
          "id",
          "name",
          "api_key",
          "organization_id",
          "created_by",
          "created_at"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "API key ID",
            "description": "String ID of API key. Starts with `key_`. This is an ID that can be used to revoke keys, and is not the key itself.",
            "type": "string"
          },
          "name": {
            "title": "API key name",
            "description": "Displayed name of the generated API key.",
            "type": "string"
          },
          "api_key": {
            "title": "API key",
            "description": "The API key. This is censored and will only contain a few leading and trailing characters.",
            "type": "string"
          },
          "organization_id": {
            "title": "Organization ID",
            "description": "String ID of organization that the API key belongs to. Starts with `org_`.",
            "type": "string"
          },
          "created_by": {
            "title": "Created by",
            "description": "The user that created the API key.",
            "allOf": [
              {
                "$ref": "#/components/schemas/UserResponse"
              }
            ]
          },
          "last_used": {
            "title": "Last used",
            "description": "The most recent time the API key was used to authenticate a request.",
            "type": "string",
            "format": "date-time"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "BaseMetricResponse": {
        "title": "BaseMetricResponse",
        "required": [
          "id",
          "name",
          "description",
          "code",
          "default",
          "active",
          "created_at",
          "updated_at"
        ],
        "type": "object",
        "properties": {
          "description": {
            "title": "Metric description",
            "description": "A description of what the metric measures.",
            "type": "string"
          },
          "id": {
            "title": "Metric ID",
            "description": "ID of the metric. Starts with 'metric_'.",
            "type": "string"
          },
          "name": {
            "title": "Metric name",
            "description": "The name of the metric.",
            "type": "string"
          },
          "code": {
            "title": "Metric code",
            "description": "Python code used to calculate a metric value on each logged datapoint.",
            "type": "string"
          },
          "default": {
            "title": "Metric default flag",
            "description": "Whether the metric is a global default metric. Metrics with this flag enabled cannot be deleted or modified.",
            "type": "boolean"
          },
          "active": {
            "title": "Metric active flag",
            "description": "If enabled, the metric is calculated for every logged datapoint.",
            "type": "boolean"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "CategoricalFeedbackLabel": {
        "title": "CategoricalFeedbackLabel",
        "required": ["value", "sentiment"],
        "type": "object",
        "properties": {
          "value": {
            "title": "Label value",
            "type": "string"
          },
          "sentiment": {
            "title": "Feedback label sentiment",
            "description": "Whether the feedback sentiment is positive or negative.",
            "allOf": [
              {
                "$ref": "#/components/schemas/LabelSentiment"
              }
            ]
          }
        }
      },
      "CreateExperimentRequest": {
        "title": "CreateExperimentRequest",
        "required": ["name", "positive_labels"],
        "type": "object",
        "properties": {
          "name": {
            "title": "Experiment name",
            "description": "Name of experiment.",
            "type": "string"
          },
          "model_config_ids": {
            "title": "Model config IDs",
            "description": "Model configs to add to this experiment. Further model configs can be added later.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "positive_labels": {
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            }
          },
          "set_active": {
            "title": "Set as project's active experiment",
            "description": "Whether to set the created project as the project's active experiment.",
            "type": "boolean",
            "default": false
          }
        }
      },
      "CreateLogResponse": {
        "title": "CreateLogResponse",
        "required": ["id", "project_id"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Datapoint ID",
            "description": "String ID of logged datapoint. Starts with `data_`.",
            "type": "string"
          },
          "project_id": {
            "title": "Project ID",
            "description": "String ID of project the experiment belongs to. Starts with `pr_`.",
            "type": "string"
          }
        }
      },
      "CreateMetricRequest": {
        "title": "CreateMetricRequest",
        "required": ["name", "description", "code"],
        "type": "object",
        "properties": {
          "description": {
            "title": "Metric description",
            "description": "Description of the metric to be created.",
            "type": "string"
          },
          "name": {
            "title": "Metric name",
            "description": "Name of the metric to be created.",
            "type": "string"
          },
          "code": {
            "title": "Metric code",
            "description": "Python code used to calculate a metric value on each logged datapoint. The last defined function in the code block will be called with a `log` dict, and should return a number, or `None`.",
            "type": "string"
          }
        }
      },
      "CreateOrgToolRequest": {
        "title": "CreateOrgToolRequest",
        "required": ["spec"],
        "type": "object",
        "properties": {
          "description": {
            "title": "Tool description",
            "description": "Organization's description for the tool. If not provided, the spec description will be used",
            "type": "string"
          },
          "name": {
            "title": "Tool name",
            "description": "Organizations name for the tool. If not provided, the spec name will be used",
            "type": "string"
          },
          "func_name": {
            "title": "Function name",
            "description": "Name of the function as it called",
            "type": "string"
          },
          "setup_values": {
            "title": "Tool setup values",
            "description": "Any setup values needed to set the tool as active - retrieve what setup values are required from GET on v3/tools",
            "type": "object"
          },
          "status": {
            "title": "Tool status",
            "description": "Whether the tool has been set up by the org.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OrganizationToolStatus"
              }
            ]
          },
          "spec": {
            "title": "Spec name",
            "description": "Unique name of tool spec. Retrieve from GET on /v3/tools",
            "type": "string"
          }
        }
      },
      "CreateProjectRequest": {
        "title": "CreateProjectRequest",
        "required": ["name"],
        "type": "object",
        "properties": {
          "name": {
            "title": "Project name",
            "description": "Unique project name.",
            "type": "string"
          },
          "feedback_types": {
            "title": "Feedback types",
            "description": "Feedback types to be created.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackTypeRequest"
            }
          }
        }
      },
      "DataResponse": {
        "title": "DataResponse",
        "required": [
          "id",
          "index",
          "output",
          "raw_output",
          "inputs",
          "model_config_id"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "Data ID",
            "description": "Unique ID for the model inputs and output logged to Humanloop. Use this when recording feedback later.",
            "type": "string"
          },
          "index": {
            "title": "Sample index",
            "description": "The index for the sampled generation for a given input. The num_samples request parameter controls how many samples are generated.",
            "type": "integer"
          },
          "output": {
            "title": "Sanitized output text",
            "description": "Output text returned from the provider model with leading and trailing whitespaces stripped.",
            "type": "string"
          },
          "raw_output": {
            "title": "Provider's output text",
            "description": "Raw output text returned from the provider model.",
            "type": "string"
          },
          "inputs": {
            "title": "Inputs",
            "description": "The inputs passed to the prompt template to send to provider model.",
            "type": "object"
          },
          "finish_reason": {
            "title": "Finish reason",
            "description": "Why the completion ended. Usually one of 'stop' (indicating a stop token was encountered), or 'length' (indicating the max tokens limit has been reached). It will be set as null for the intermediary responses during a stream, and will only be set as non-null for the final streamed token.",
            "type": "string"
          },
          "model_config_id": {
            "title": "The ID of your model configuration",
            "description": "The model configuration used to create the generation.",
            "type": "string"
          },
          "tools": {
            "title": "Tool results",
            "description": "Results of any tools run during the generation.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ToolResultResponse"
            }
          }
        }
      },
      "ExperimentGenerate": {
        "title": "ExperimentGenerate",
        "required": ["project", "inputs", "provider_api_keys", "experiment_id"],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. The model configuration will be added to the project if necessary.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of name, value pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "source": {
            "title": "Source",
            "description": "What was source of the model used for this generation?e.g. website-landing-page",
            "type": "string"
          },
          "provider_api_keys": {
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. These API keys are not stored by Humanloop.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ]
          },
          "num_samples": {
            "title": "Number of samples",
            "description": "How many generations to make for each set of inputs. Each generate will sample a model config for an experiment.",
            "type": "integer",
            "default": 1
          },
          "logprobs": {
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response",
            "type": "integer"
          },
          "stream": {
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events as they become available. If num_samples > 1, samples are streamed back independently. The stream for each sample will be terminated with a non-null finish_reason.",
            "type": "boolean",
            "default": false
          },
          "suffix": {
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
            "type": "string"
          },
          "user": {
            "title": "End-user identifier",
            "description": "End-user id passed through to provider call.",
            "type": "string"
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          },
          "experiment_id": {
            "title": "ID of experiment",
            "description": "If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations.",
            "type": "string"
          }
        }
      },
      "ExperimentModelConfigResponse": {
        "title": "ExperimentModelConfigResponse",
        "required": [
          "trials_count",
          "active",
          "id",
          "display_name",
          "model_config",
          "created_at",
          "updated_at"
        ],
        "type": "object",
        "properties": {
          "mean": {
            "title": "Mean of experiment's metric",
            "description": "The mean performance of the model config, as measured by the experiment's metric.",
            "type": "number"
          },
          "spread": {
            "title": "Spread of experiment's metric",
            "description": "The spread of performance of the model config, as measured by the experiment's metric. A measure of the uncertainty in the model config's performance.",
            "type": "number"
          },
          "trials_count": {
            "title": "The number of trials that have happened in this experiment",
            "description": "Number of datapoints with feedback associated to this experiment.",
            "type": "integer"
          },
          "active": {
            "title": "Model config active",
            "description": "Whether the model config is active in the experiment. Only active model configs can be sampled from the experiment.",
            "type": "boolean"
          },
          "id": {
            "title": "Model config ID",
            "description": "String ID of model config. Starts with `config_`.",
            "type": "string"
          },
          "display_name": {
            "title": "Display name",
            "description": "Display name of model config. If this is not set by the user, a friendly name will be generated.",
            "type": "string"
          },
          "model_config": {
            "title": "Model config",
            "description": "Full definition of model config used in the experiment.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigResponse"
              }
            ]
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ExperimentResponse": {
        "title": "ExperimentResponse",
        "required": [
          "id",
          "project_id",
          "name",
          "status",
          "metric",
          "positive_labels",
          "created_at",
          "updated_at"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "Experiment ID",
            "description": "String ID of experiment. Starts with `exp_`.",
            "type": "string"
          },
          "project_id": {
            "title": "Project ID",
            "description": "String ID of project the experiment belongs to. Starts with `pr_`.",
            "type": "string"
          },
          "name": {
            "title": "Experiment name",
            "description": "Name of experiment.",
            "type": "string"
          },
          "status": {
            "title": "Experiment status",
            "description": "Status of experiment.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ExperimentStatus"
              }
            ]
          },
          "model_configs": {
            "title": "Experiment model configs",
            "description": "List of model configs associated to the experiment.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperimentModelConfigResponse"
            }
          },
          "metric": {
            "title": "Experiment metric",
            "description": "Metric used as the experiment's objective.",
            "allOf": [
              {
                "$ref": "#/components/schemas/BaseMetricResponse"
              }
            ]
          },
          "positive_labels": {
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            }
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ExperimentStatus": {
        "title": "ExperimentStatus",
        "description": "An enumeration.",
        "enum": ["Initialized", "In progress"],
        "type": "string"
      },
      "Feedback": {
        "title": "Feedback",
        "required": ["type", "value"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ]
          },
          "value": {
            "title": "Feedback value",
            "description": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
            "type": "string"
          },
          "data_id": {
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint.When providing instant feedback as part of the hl.log(...) call you don't need to provide a data_id.",
            "type": "string"
          },
          "user": {
            "title": "User",
            "description": "A unique identifier to who provided the feedback. This gets passed through to the provider as required.",
            "type": "string"
          },
          "created_at": {
            "title": "Created at",
            "description": "Timestamp for when the feedback was created. If not provided, the time the call was made will be used as a timestamp.",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "FeedbackClass": {
        "title": "FeedbackClass",
        "description": "An enumeration.",
        "enum": ["select", "multi_select", "text"],
        "type": "string"
      },
      "FeedbackLabelRequest": {
        "title": "FeedbackLabelRequest",
        "required": ["value"],
        "type": "object",
        "properties": {
          "value": {
            "title": "Value",
            "type": "string"
          },
          "sentiment": {
            "$ref": "#/components/schemas/LabelSentiment"
          }
        }
      },
      "FeedbackRequest": {
        "title": "FeedbackRequest",
        "required": ["type"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ]
          },
          "value": {
            "title": "Feedback value",
            "description": "The feedback value to be set. This field should be left blank when unsetting 'rating', 'correction' or 'comment', but is required otherwise.",
            "type": "string"
          },
          "data_id": {
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint.When providing instant feedback as part of the hl.log(...) call you don't need to provide a data_id.",
            "type": "string"
          },
          "user": {
            "title": "User",
            "description": "A unique identifier to who provided the feedback. This gets passed through to the provider as required.",
            "type": "string"
          },
          "created_at": {
            "title": "Created at",
            "description": "Timestamp for when the feedback was created. If not provided, the time the call was made will be used as a timestamp.",
            "type": "string",
            "format": "date-time"
          },
          "unset": {
            "title": "Unset",
            "description": "If true, the value for this feedback type is unset.",
            "type": "boolean"
          }
        }
      },
      "FeedbackResponse": {
        "title": "FeedbackResponse",
        "required": ["type", "value", "id"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ]
          },
          "value": {
            "title": "Feedback value",
            "description": "The feedback value to set. This would be the appropriate text for 'correction' or 'comment', or a label to apply for 'rating', 'action', or 'issue'.",
            "type": "string"
          },
          "data_id": {
            "title": "Datapoint ID",
            "description": "ID to associate the feedback to a previously logged datapoint.When providing instant feedback as part of the hl.log(...) call you don't need to provide a data_id.",
            "type": "string"
          },
          "user": {
            "title": "User",
            "description": "A unique identifier to who provided the feedback. This gets passed through to the provider as required.",
            "type": "string"
          },
          "created_at": {
            "title": "Created at",
            "description": "Timestamp for when the feedback was created. If not provided, the time the call was made will be used as a timestamp.",
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "title": "Feedback ID",
            "description": "String ID of user feedback. Starts with `ann_`, short for annotation.",
            "type": "string"
          }
        }
      },
      "FeedbackType": {
        "title": "FeedbackType",
        "description": "An enumeration.",
        "enum": ["rating", "action", "issue", "correction", "comment"],
        "type": "string"
      },
      "FeedbackTypeModel": {
        "title": "FeedbackTypeModel",
        "required": ["type"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "description": "The type of feedback. The default feedback types available are 'rating', 'action', 'issue', 'correction', and 'comment'.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/FeedbackType"
              },
              {
                "type": "string"
              }
            ]
          },
          "values": {
            "title": "Allowed values for categorical feedback types",
            "description": "The allowed values for categorical feedback types. Not populated for `correction` and `comment`.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CategoricalFeedbackLabel"
            }
          }
        }
      },
      "FeedbackTypeRequest": {
        "title": "FeedbackTypeRequest",
        "required": ["type"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "description": "The type of feedback to update.",
            "type": "string"
          },
          "values": {
            "title": "Feedback label values",
            "description": "The feedback values to be available. This field should only be populated when updating a 'select' or 'multi_select' feedback class.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackLabelRequest"
            }
          },
          "class": {
            "title": "Feedback class",
            "description": "The data type associated to this feedback type; whether it is a 'text'/'select'/'multi_select'. This is optional when updating the default feedback types (i.e. when `type` is 'rating', 'action' or 'issue').",
            "allOf": [
              {
                "$ref": "#/components/schemas/FeedbackClass"
              }
            ]
          }
        }
      },
      "FeedbackTypes": {
        "title": "FeedbackTypes",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/FeedbackTypeModel"
        }
      },
      "GenerateResponse": {
        "title": "GenerateResponse",
        "required": ["project_id", "data", "provider_responses"],
        "type": "object",
        "properties": {
          "project_id": {
            "title": "Project id",
            "description": "Unique identifier of the parent project.",
            "type": "string"
          },
          "num_samples": {
            "title": "Number of samples",
            "description": "How many generates to make for each set of inputs.",
            "type": "integer",
            "default": 1
          },
          "logprobs": {
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response",
            "type": "integer"
          },
          "suffix": {
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
            "type": "string"
          },
          "user": {
            "title": "End-user identifier",
            "description": "End-user id passed through to provider call.",
            "type": "string"
          },
          "data": {
            "title": "Logged data",
            "description": "Array containing the details of the resulting generations.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/DataResponse"
            }
          },
          "usage": {
            "title": "Usage",
            "description": "Counts of the number of tokens used and related stats.",
            "allOf": [
              {
                "$ref": "#/components/schemas/GenerateUsage"
              }
            ]
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          },
          "provider_responses": {
            "title": "Provider responses",
            "description": "The full raw responses provided by the calls to the provider.",
            "type": "array",
            "items": {}
          }
        }
      },
      "GenerateUsage": {
        "title": "GenerateUsage",
        "required": ["prompt_tokens", "generation_tokens", "total_tokens"],
        "type": "object",
        "properties": {
          "prompt_tokens": {
            "title": "Prompt tokens",
            "description": "Number of tokens used in the prompt.",
            "type": "integer"
          },
          "generation_tokens": {
            "title": "Generation tokens",
            "description": "Number of tokens produced by the generation.",
            "type": "integer"
          },
          "total_tokens": {
            "title": "Total tokens",
            "description": "Total number of tokens used by the prompt and generation combined.",
            "type": "integer"
          }
        }
      },
      "GetModelConfigResponse": {
        "title": "GetModelConfigResponse",
        "description": "A selected model configuration.\n\nIf the model configuration was selected in the context of an experiment,\nthe response will include a trial_id to associate a subsequent log() call.",
        "required": [
          "model",
          "prompt_template",
          "id",
          "created_at",
          "updated_at",
          "last_used"
        ],
        "type": "object",
        "properties": {
          "provider": {
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "default": "openai"
          },
          "endpoint": {
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "default": "complete"
          },
          "model": {
            "title": "Model instance used",
            "description": "What model instance to use for the generation. e.g. text-davinci-002.",
            "type": "string"
          },
          "prompt_template": {
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "string"
          },
          "temperature": {
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "number",
            "default": 1
          },
          "max_tokens": {
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate in the completion.",
            "type": "integer",
            "default": 16
          },
          "top_p": {
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "number",
            "default": 1
          },
          "stop": {
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "presence_penalty": {
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "frequency_penalty": {
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "other": {
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "type": "object",
            "default": {}
          },
          "id": {
            "title": "Model config ID",
            "description": "Model config unique identifier generated by Humanloop.",
            "type": "string"
          },
          "display_name": {
            "title": "Model config name",
            "description": "A friendly display name for the model config.",
            "type": "string"
          },
          "project_id": {
            "title": "Project ID",
            "description": "String ID of project the model config belongs to. Starts with `pr_`.",
            "type": "string"
          },
          "project_name": {
            "title": "Project name",
            "description": "Name of the project the model config belongs to.",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "last_used": {
            "title": "Last Used",
            "type": "string",
            "format": "date-time"
          },
          "feedback_stats": {
            "title": "Feedback Stats",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProjectModelConfigFeedbackStatsResponse"
            }
          },
          "experiment_id": {
            "title": "Experiment ID",
            "description": "The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.",
            "type": "string"
          },
          "trial_id": {
            "title": "Trial ID",
            "description": "ID of trial to reference in subsequent log calls.",
            "type": "string"
          }
        }
      },
      "HTTPValidationError": {
        "title": "HTTPValidationError",
        "type": "object",
        "properties": {
          "detail": {
            "title": "Detail",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            }
          }
        }
      },
      "LabelSentiment": {
        "title": "LabelSentiment",
        "description": "How a label should be treated in calculating model config performance.\n\nUsed by a project's PAPV metric.",
        "enum": ["positive", "negative", "neutral", "unset"],
        "type": "string"
      },
      "LogRequest": {
        "title": "LogRequest",
        "required": ["project", "inputs", "output"],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. If it does not exist, a new project will be created.",
            "type": "string"
          },
          "trial_id": {
            "title": "Trial ID",
            "description": "Unique ID of trial to associate to a log to inform an experiment.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of (name, value) pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "output": {
            "title": "Model output",
            "description": "Generated output from your model for the provided inputs.",
            "type": "string"
          },
          "source": {
            "title": "Source of generation",
            "description": "What was source of the model used for this generation? e.g. website-landing-page",
            "type": "string"
          },
          "model_config": {
            "title": "Model config",
            "description": "The model config used for this generation. Required unless `trial_id` is provided.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigRequest"
              }
            ]
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          },
          "feedback": {
            "title": "Feedback labels",
            "description": "Optional parameter to provide feedback with your logged datapoint.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/Feedback"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Feedback"
                }
              }
            ]
          },
          "created_at": {
            "title": "Created at",
            "description": "Timestamp for when the log was created. If not provided, the time the log call was made will be used as a timestamp.",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "LogResponse": {
        "title": "LogResponse",
        "required": ["project", "inputs", "output", "id", "project_id"],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. If it does not exist, a new project will be created.",
            "type": "string"
          },
          "trial_id": {
            "title": "Trial ID",
            "description": "Unique ID of trial to associate to a log to inform an experiment.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of (name, value) pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "output": {
            "title": "Model output",
            "description": "Generated output from your model for the provided inputs.",
            "type": "string"
          },
          "source": {
            "title": "Source of generation",
            "description": "What was source of the model used for this generation? e.g. website-landing-page",
            "type": "string"
          },
          "model_config": {
            "title": "Model config",
            "description": "The model config used for this generation",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectModelConfigResponse"
              }
            ]
          },
          "metadata": {
            "title": "Metadata",
            "description": "Additional metadata logged for reference.",
            "type": "object"
          },
          "feedback": {
            "title": "Feedback",
            "description": "Feedback associated to the datapoint.",
            "anyOf": [
              {
                "$ref": "#/components/schemas/Feedback"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/Feedback"
                }
              }
            ]
          },
          "created_at": {
            "title": "Created at",
            "description": "Timestamp for when the log was created.",
            "type": "string",
            "format": "date-time"
          },
          "id": {
            "title": "Datapoint ID",
            "description": "String ID of logged datapoint. Starts with `data_`.",
            "type": "string"
          },
          "project_id": {
            "title": "Project ID",
            "description": "String ID of project the datapoint belongs to. Starts with `pr_`.",
            "type": "string"
          }
        }
      },
      "MetricExperimentResponse": {
        "title": "MetricExperimentResponse",
        "required": ["id", "name"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Experiment ID",
            "description": "String ID of experiment. Starts with `exp_`.",
            "type": "string"
          },
          "name": {
            "title": "Experiment name",
            "description": "Name of experiment.",
            "type": "string"
          }
        }
      },
      "MetricResponse": {
        "title": "MetricResponse",
        "required": [
          "id",
          "name",
          "description",
          "code",
          "default",
          "active",
          "created_at",
          "updated_at",
          "experiments",
          "num_values"
        ],
        "type": "object",
        "properties": {
          "description": {
            "title": "Metric description",
            "description": "A description of what the metric measures.",
            "type": "string"
          },
          "id": {
            "title": "Metric ID",
            "description": "ID of the metric. Starts with 'metric_'.",
            "type": "string"
          },
          "name": {
            "title": "Metric name",
            "description": "The name of the metric.",
            "type": "string"
          },
          "code": {
            "title": "Metric code",
            "description": "Python code used to calculate a metric value on each logged datapoint.",
            "type": "string"
          },
          "default": {
            "title": "Metric default flag",
            "description": "Whether the metric is a global default metric. Metrics with this flag enabled cannot be deleted or modified.",
            "type": "boolean"
          },
          "active": {
            "title": "Metric active flag",
            "description": "If enabled, the metric is calculated for every logged datapoint.",
            "type": "boolean"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "experiments": {
            "title": "Experiments using the metric",
            "description": "List of experiments optimizing for this metric.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/MetricExperimentResponse"
            }
          },
          "num_values": {
            "title": "Number of values",
            "description": "Number of datapoints this metric has been calculated on. This does not include datapoints where the metric returned `None`.",
            "type": "integer"
          }
        }
      },
      "ModelConfigGenerate": {
        "title": "ModelConfigGenerate",
        "required": [
          "project",
          "inputs",
          "provider_api_keys",
          "model_config_id"
        ],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. The model configuration will be added to the project if necessary.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of name, value pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "source": {
            "title": "Source",
            "description": "What was source of the model used for this generation?e.g. website-landing-page",
            "type": "string"
          },
          "provider_api_keys": {
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. These API keys are not stored by Humanloop.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ]
          },
          "num_samples": {
            "title": "Number of samples",
            "description": "How many generations to make for each set of inputs for the specified model config.",
            "type": "integer",
            "default": 1
          },
          "logprobs": {
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response",
            "type": "integer"
          },
          "stream": {
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events as they become available. If num_samples > 1, samples are streamed back independently. The stream for each sample will be terminated with a non-null finish_reason.",
            "type": "boolean",
            "default": false
          },
          "suffix": {
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
            "type": "string"
          },
          "user": {
            "title": "End-user identifier",
            "description": "End-user id passed through to provider call.",
            "type": "string"
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          },
          "model_config_id": {
            "title": "ID of a model config",
            "description": "The model configuration specified will be used to create a generation.",
            "type": "string"
          }
        }
      },
      "ModelConfigRequest": {
        "title": "ModelConfigRequest",
        "description": "Core ModelConfig request model.\nFollowing closely: https://beta.openai.com/docs/api-reference/completions/create",
        "required": ["model", "prompt_template"],
        "type": "object",
        "properties": {
          "provider": {
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "default": "openai"
          },
          "endpoint": {
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "default": "complete"
          },
          "model": {
            "title": "Model instance used",
            "description": "What model instance to use for the generation. e.g. text-davinci-002.",
            "type": "string"
          },
          "prompt_template": {
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "string"
          },
          "temperature": {
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "number",
            "default": 1
          },
          "max_tokens": {
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate in the completion.",
            "type": "integer",
            "default": 16
          },
          "top_p": {
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "number",
            "default": 1
          },
          "stop": {
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "presence_penalty": {
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "frequency_penalty": {
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "other": {
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "type": "object",
            "default": {}
          }
        }
      },
      "ModelConfigResponse": {
        "title": "ModelConfigResponse",
        "description": "Extends the core ModelConfig request object to include Humanloop generated\nidentifier and method for serializing response from ModelConfig domain object.",
        "required": ["model", "prompt_template", "id"],
        "type": "object",
        "properties": {
          "provider": {
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "default": "openai"
          },
          "endpoint": {
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "default": "complete"
          },
          "model": {
            "title": "Model instance used",
            "description": "What model instance to use for the generation. e.g. text-davinci-002.",
            "type": "string"
          },
          "prompt_template": {
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "string"
          },
          "temperature": {
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "number",
            "default": 1
          },
          "max_tokens": {
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate in the completion.",
            "type": "integer",
            "default": 16
          },
          "top_p": {
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "number",
            "default": 1
          },
          "stop": {
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "presence_penalty": {
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "frequency_penalty": {
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "other": {
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "type": "object",
            "default": {}
          },
          "id": {
            "title": "Model config ID",
            "description": "Model config unique identifier generated by Humanloop.",
            "type": "string"
          },
          "display_name": {
            "title": "Model config name",
            "description": "A friendly display name for the model config.",
            "type": "string"
          }
        }
      },
      "ModelEndpoints": {
        "title": "ModelEndpoints",
        "description": "Supported model provider endpoints.",
        "enum": ["complete", "edit"],
        "type": "string"
      },
      "ModelProviders": {
        "title": "ModelProviders",
        "description": "Supported model providers.",
        "enum": ["openai", "ai21", "mock", "anthropic"],
        "type": "string"
      },
      "OrganizationResponse": {
        "title": "OrganizationResponse",
        "required": [
          "name",
          "id",
          "created_at",
          "updated_at",
          "teams",
          "users"
        ],
        "type": "object",
        "properties": {
          "name": {
            "title": "Organization name",
            "type": "string"
          },
          "slug": {
            "title": "Organization unique slug",
            "description": "A unique slug that will be used for the organization. Only accepts letters, numbers, and hyphens.",
            "type": "string"
          },
          "id": {
            "title": "Organization ID",
            "description": "String ID of organization. Starts with `org_`.",
            "type": "string"
          },
          "active_subscription": {
            "title": "Active subscription",
            "description": "The active subscription of the organization including product information. If None the org has no active subscription.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ActiveSubscriptionResponse"
              }
            ]
          },
          "customer_id": {
            "title": "Stripe customer ID",
            "description": "The customer ID of the organization in stripe. None if they have never made a subscription.",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "teams": {
            "title": "Teams",
            "description": "Teams associated to this organization.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TeamResponse"
            }
          },
          "users": {
            "title": "Users",
            "description": "Users in this organization",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/OrganizationUserResponse"
            }
          }
        }
      },
      "OrganizationToolResponse": {
        "title": "OrganizationToolResponse",
        "required": [
          "id",
          "name",
          "description",
          "signature",
          "status",
          "spec"
        ],
        "type": "object",
        "properties": {
          "description": {
            "title": "Org tool description",
            "description": "Organization's description for the tool.",
            "type": "string"
          },
          "id": {
            "title": "Organization tool ID",
            "description": "Unique ID for the orgs tool setup.",
            "type": "string"
          },
          "name": {
            "title": "Org tool name",
            "description": "Organization's name for the tool.",
            "type": "string"
          },
          "signature": {
            "title": "Org tool signature",
            "description": "The call signature for the tool of its name and parameters which is used to call the tool from the `prompt_template`.",
            "type": "string"
          },
          "status": {
            "title": "Tool status",
            "description": "Whether the tool has been set up by the org.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OrganizationToolStatus"
              }
            ]
          },
          "setup_values": {
            "title": "Setup values",
            "description": "Values used to set up the tool - following the spec's setup model.",
            "type": "object"
          },
          "spec": {
            "title": "Tool spec",
            "description": "The specification of the tool's requirements for setup and execution.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ToolSpecResponse"
              }
            ]
          }
        }
      },
      "OrganizationToolStatus": {
        "title": "OrganizationToolStatus",
        "description": "An enumeration.",
        "enum": ["active", "inactive"],
        "type": "string"
      },
      "OrganizationUserResponse": {
        "title": "OrganizationUserResponse",
        "required": ["id", "email_address", "verified", "role"],
        "type": "object",
        "properties": {
          "id": {
            "title": "User ID",
            "description": "String ID of user. Starts with `usr_`.",
            "type": "string"
          },
          "email_address": {
            "title": "Email address",
            "description": "The user's email address.",
            "type": "string"
          },
          "full_name": {
            "title": "Full name",
            "description": "The user's full name.",
            "type": "string"
          },
          "verified": {
            "title": "Verified",
            "description": "Whether the user has verified their email address.",
            "type": "boolean"
          },
          "feature_flags": {
            "title": "Feature Flags",
            "type": "object",
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "role": {
            "$ref": "#/components/schemas/UserOrganizationRole"
          }
        }
      },
      "PaginatedData_LogResponse_": {
        "title": "PaginatedData[LogResponse]",
        "required": ["records", "page", "size", "total"],
        "type": "object",
        "properties": {
          "records": {
            "title": "Records",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogResponse"
            }
          },
          "page": {
            "title": "Page",
            "type": "integer"
          },
          "size": {
            "title": "Size",
            "type": "integer"
          },
          "total": {
            "title": "Total",
            "type": "integer"
          }
        }
      },
      "PaginatedData_ProjectResponse_": {
        "title": "PaginatedData[ProjectResponse]",
        "required": ["records", "page", "size", "total"],
        "type": "object",
        "properties": {
          "records": {
            "title": "Records",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProjectResponse"
            }
          },
          "page": {
            "title": "Page",
            "type": "integer"
          },
          "size": {
            "title": "Size",
            "type": "integer"
          },
          "total": {
            "title": "Total",
            "type": "integer"
          }
        }
      },
      "PaymentInterval": {
        "title": "PaymentInterval",
        "description": "Interval units used for pricing and usage.",
        "enum": ["month", "year", "week", "day"],
        "type": "string"
      },
      "PositiveLabel": {
        "title": "PositiveLabel",
        "required": ["type", "value"],
        "type": "object",
        "properties": {
          "type": {
            "title": "Feedback type",
            "type": "string"
          },
          "value": {
            "title": "Feedback value",
            "type": "string"
          }
        }
      },
      "PriceResponse": {
        "title": "PriceResponse",
        "required": ["id", "interval", "subscription_duration", "model"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "interval": {
            "$ref": "#/components/schemas/PaymentInterval"
          },
          "subscription_duration": {
            "$ref": "#/components/schemas/SubscriptionDuration"
          },
          "model": {
            "$ref": "#/components/schemas/PricingModel"
          },
          "data_limit": {
            "title": "Data limit",
            "description": "Value over which usage pricing kicks in at num datapoints used x unit price.",
            "type": "integer"
          },
          "data_unit_price": {
            "title": "Data Unit Price",
            "type": "number"
          },
          "data_unit_currency": {
            "title": "Data Unit Currency",
            "type": "string"
          }
        }
      },
      "PricingModel": {
        "title": "PricingModel",
        "description": "Models of pricing - fixed or graduated usage based",
        "enum": ["fixed", "usage"],
        "type": "string"
      },
      "ProductResponse": {
        "title": "ProductResponse",
        "required": ["id", "name", "prices", "seats_limit"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "prices": {
            "title": "Prices",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PriceResponse"
            }
          },
          "seats_limit": {
            "title": "Seats Limit",
            "type": "integer"
          },
          "feature_flags": {
            "title": "Feature Flags",
            "type": "object",
            "additionalProperties": {
              "type": "boolean"
            }
          }
        }
      },
      "ProjectGenerate": {
        "title": "ProjectGenerate",
        "description": "Alias for BaseGenerate that providers a better name for the consumer of docs",
        "required": ["project", "inputs", "provider_api_keys"],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. This project must already have an active deployment configured.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of name, value pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "source": {
            "title": "Source",
            "description": "What was source of the model used for this generation?e.g. website-landing-page",
            "type": "string"
          },
          "provider_api_keys": {
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. These API keys are not stored by Humanloop.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ]
          },
          "num_samples": {
            "title": "Number of samples",
            "description": "How many generations to make for each set of inputs for the specified model config.",
            "type": "integer",
            "default": 1
          },
          "logprobs": {
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response",
            "type": "integer"
          },
          "stream": {
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events as they become available. If num_samples > 1, samples are streamed back independently. The stream for each sample will be terminated with a non-null finish_reason.",
            "type": "boolean",
            "default": false
          },
          "suffix": {
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
            "type": "string"
          },
          "user": {
            "title": "End-user identifier",
            "description": "End-user id passed through to provider call.",
            "type": "string"
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          }
        }
      },
      "ProjectModelConfigFeedbackStatsResponse": {
        "title": "ProjectModelConfigFeedbackStatsResponse",
        "required": [
          "feedback_group_id",
          "feedback_group_name",
          "feedback_label",
          "feedback_count"
        ],
        "type": "object",
        "properties": {
          "feedback_group_id": {
            "title": "Feedback Group Id",
            "type": "integer"
          },
          "feedback_group_name": {
            "title": "Feedback Group Name",
            "type": "string"
          },
          "feedback_label": {
            "title": "Feedback Label",
            "type": "string"
          },
          "feedback_count": {
            "title": "Feedback Count",
            "type": "integer"
          }
        }
      },
      "ProjectModelConfigRequest": {
        "title": "ProjectModelConfigRequest",
        "description": "Core ModelConfig request model.\nFollowing closely: https://beta.openai.com/docs/api-reference/completions/create",
        "required": ["model", "prompt_template", "project"],
        "type": "object",
        "properties": {
          "provider": {
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "default": "openai"
          },
          "endpoint": {
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "default": "complete"
          },
          "model": {
            "title": "Model instance used",
            "description": "What model instance to use for the generation. e.g. text-davinci-002.",
            "type": "string"
          },
          "prompt_template": {
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "string"
          },
          "temperature": {
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "number",
            "default": 1
          },
          "max_tokens": {
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate in the completion.",
            "type": "integer",
            "default": 16
          },
          "top_p": {
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "number",
            "default": 1
          },
          "stop": {
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "presence_penalty": {
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "frequency_penalty": {
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "other": {
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "type": "object",
            "default": {}
          },
          "project": {
            "title": "Project name",
            "description": "Unique project name. If it does not exist, a new project will be created.",
            "type": "string"
          },
          "name": {
            "title": "Model config name",
            "description": "A friendly display name for the model config. If not provided, a name will be generated.",
            "type": "string"
          },
          "experiment": {
            "title": "Experiment name",
            "description": "If specified, the model config will be added to this experiment. Experiments are used for A/B testing and optimizing hyperparameters.",
            "type": "string"
          }
        }
      },
      "ProjectModelConfigResponse": {
        "title": "ProjectModelConfigResponse",
        "description": "Extends the core ModelConfig request object to include Humanloop generated\nidentifier and method for serializing response from ModelConfig domain object.",
        "required": [
          "model",
          "prompt_template",
          "id",
          "created_at",
          "updated_at",
          "last_used"
        ],
        "type": "object",
        "properties": {
          "provider": {
            "title": "Model provider",
            "description": "The company providing the underlying model service.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelProviders"
              }
            ],
            "default": "openai"
          },
          "endpoint": {
            "title": "Provider endpoint",
            "description": "Which of the providers model endpoints to use. For example Complete or Edit.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelEndpoints"
              }
            ],
            "default": "complete"
          },
          "model": {
            "title": "Model instance used",
            "description": "What model instance to use for the generation. e.g. text-davinci-002.",
            "type": "string"
          },
          "prompt_template": {
            "title": "Prompt template",
            "description": "Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.",
            "type": "string"
          },
          "temperature": {
            "title": "Sampling temperature",
            "description": "What sampling temperature to use when making a generation. Higher values means the model will be more creative.",
            "type": "number",
            "default": 1
          },
          "max_tokens": {
            "title": "Maximum tokens",
            "description": "The maximum number of tokens to generate in the completion.",
            "type": "integer",
            "default": 16
          },
          "top_p": {
            "title": "Top p probability mass",
            "description": "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.",
            "type": "number",
            "default": 1
          },
          "stop": {
            "title": "Stop sequence(s)",
            "description": "The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.",
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "presence_penalty": {
            "title": "Penalize tokens on whether present.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "frequency_penalty": {
            "title": "Penalize tokens on whether frequent.",
            "description": "Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.",
            "type": "number",
            "default": 0
          },
          "other": {
            "title": "Other provider parameters",
            "description": "Other parameter values to be passed to the provider call.",
            "type": "object",
            "default": {}
          },
          "id": {
            "title": "Model config ID",
            "description": "Model config unique identifier generated by Humanloop.",
            "type": "string"
          },
          "display_name": {
            "title": "Model config name",
            "description": "A friendly display name for the model config.",
            "type": "string"
          },
          "project_id": {
            "title": "Project ID",
            "description": "String ID of project the model config belongs to. Starts with `pr_`.",
            "type": "string"
          },
          "project_name": {
            "title": "Project name",
            "description": "Name of the project the model config belongs to.",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "last_used": {
            "title": "Last Used",
            "type": "string",
            "format": "date-time"
          },
          "feedback_stats": {
            "title": "Feedback Stats",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProjectModelConfigFeedbackStatsResponse"
            }
          },
          "experiment_id": {
            "title": "Experiment ID",
            "description": "The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.",
            "type": "string"
          }
        }
      },
      "ProjectResponse": {
        "title": "ProjectResponse",
        "required": [
          "id",
          "internal_id",
          "name",
          "users",
          "data_count",
          "feedback_types",
          "team_id",
          "created_at",
          "updated_at"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "Project ID",
            "description": "Project ID",
            "type": "string"
          },
          "internal_id": {
            "title": "Internal project ID",
            "description": "Project ID for internal Humanloop use.",
            "type": "integer"
          },
          "name": {
            "title": "Project name",
            "description": "Unique project name.",
            "type": "string"
          },
          "active_experiment": {
            "title": "Active experiment",
            "description": "Experiment that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ExperimentResponse"
              }
            ]
          },
          "active_model_config": {
            "title": "Active model configuration",
            "description": "Model configuration that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProjectModelConfigResponse"
              }
            ]
          },
          "users": {
            "title": "Project users",
            "description": "Users associated to the project.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ProjectUserResponse"
            }
          },
          "data_count": {
            "title": "Number of datapoints",
            "description": "The count of datapoints that have been logged to the project.",
            "type": "integer"
          },
          "feedback_types": {
            "title": "Feedback types",
            "description": "The feedback types that have been defined in the project.",
            "allOf": [
              {
                "$ref": "#/components/schemas/FeedbackTypes"
              }
            ]
          },
          "team_id": {
            "title": "Team ID",
            "description": "Unique ID of the team the project belongs to. Starts with `tm_`.",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "ProjectSortBy": {
        "title": "ProjectSortBy",
        "description": "An enumeration.",
        "enum": ["created_at", "updated_at", "name"],
        "type": "string"
      },
      "ProjectUserResponse": {
        "title": "ProjectUserResponse",
        "required": ["id", "email_address"],
        "type": "object",
        "properties": {
          "id": {
            "title": "User ID",
            "description": "String ID of user. Starts with `usr_`.",
            "type": "string"
          },
          "email_address": {
            "title": "Email address",
            "description": "The user's email address.",
            "type": "string"
          },
          "full_name": {
            "title": "Full name",
            "description": "The user's full name.",
            "type": "string"
          }
        }
      },
      "ProviderApiKeys": {
        "title": "ProviderApiKeys",
        "type": "object",
        "properties": {
          "openai": {
            "title": "Openai",
            "type": "string"
          },
          "ai21": {
            "title": "Ai21",
            "type": "string"
          },
          "mock": {
            "title": "Mock",
            "type": "string"
          },
          "anthropic": {
            "title": "Anthropic",
            "type": "string"
          }
        }
      },
      "RawGenerate": {
        "title": "RawGenerate",
        "required": ["project", "inputs", "provider_api_keys", "model_config"],
        "type": "object",
        "properties": {
          "project": {
            "title": "Project name",
            "description": "Unique project name. The model configuration will be added to the project if necessary.",
            "type": "string"
          },
          "inputs": {
            "title": "Model input data",
            "description": "List of name, value pairs for the inputs used by your prompt template, or directly by your model.",
            "type": "object"
          },
          "source": {
            "title": "Source",
            "description": "What was source of the model used for this generation?e.g. website-landing-page",
            "type": "string"
          },
          "provider_api_keys": {
            "title": "Provider API Keys",
            "description": "API keys required by each provider to make API calls. These API keys are not stored by Humanloop.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ProviderApiKeys"
              }
            ]
          },
          "num_samples": {
            "title": "Number of samples",
            "description": "How many generations to make for each set of inputs for the specified model config.",
            "type": "integer",
            "default": 1
          },
          "logprobs": {
            "title": "Log probabilities of most likely n tokens",
            "description": "Include the log probabilities of the top n tokens in the provider_response",
            "type": "integer"
          },
          "stream": {
            "title": "Whether to stream partial results",
            "description": "If true, tokens will be sent as data-only server-sent events as they become available. If num_samples > 1, samples are streamed back independently. The stream for each sample will be terminated with a non-null finish_reason.",
            "type": "boolean",
            "default": false
          },
          "suffix": {
            "title": "Completion suffix",
            "description": "The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.",
            "type": "string"
          },
          "user": {
            "title": "End-user identifier",
            "description": "End-user id passed through to provider call.",
            "type": "string"
          },
          "metadata": {
            "title": "Metadata",
            "description": "Any additional metadata that you would like to log for reference.",
            "type": "object"
          },
          "model_config": {
            "title": "The configuration of your model",
            "description": "The model configuration provided will be recorded and used to create a generation.",
            "allOf": [
              {
                "$ref": "#/components/schemas/ModelConfigRequest"
              }
            ]
          }
        }
      },
      "SetupAndRunSpec": {
        "title": "SetupAndRunSpec",
        "required": ["name", "required", "type", "title", "description"],
        "type": "object",
        "properties": {
          "title": {
            "title": "Title",
            "type": "string"
          },
          "description": {
            "title": "Description",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "required": {
            "title": "Required",
            "type": "boolean"
          },
          "type": {
            "title": "Type",
            "type": "string"
          },
          "default": {
            "title": "Default"
          }
        }
      },
      "SortOrder": {
        "title": "SortOrder",
        "description": "An enumeration.",
        "enum": ["asc", "desc"],
        "type": "string"
      },
      "SubscriptionDuration": {
        "title": "SubscriptionDuration",
        "description": "An enumeration.",
        "enum": ["month", "year"],
        "type": "string"
      },
      "SubscriptionResponse": {
        "title": "SubscriptionResponse",
        "required": [
          "id",
          "status",
          "created_at",
          "product",
          "interval",
          "duration",
          "usage_reports",
          "current_period_start",
          "current_period_end",
          "current_usage"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/SubscriptionStatus"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "product": {
            "$ref": "#/components/schemas/ProductResponse"
          },
          "interval": {
            "$ref": "#/components/schemas/PaymentInterval"
          },
          "duration": {
            "$ref": "#/components/schemas/SubscriptionDuration"
          },
          "usage_reports": {
            "title": "Usage Reports",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/UsageReportResponse"
            }
          },
          "current_period_start": {
            "title": "Current Period Start",
            "type": "string",
            "format": "date-time"
          },
          "current_period_end": {
            "title": "Current Period End",
            "type": "string",
            "format": "date-time"
          },
          "cancel_at_period_end": {
            "title": "Cancel At Period End",
            "type": "boolean"
          },
          "current_usage": {
            "title": "Current Usage",
            "type": "integer"
          }
        }
      },
      "SubscriptionStatus": {
        "title": "SubscriptionStatus",
        "description": "An enumeration.",
        "enum": ["active", "inactive"],
        "type": "string"
      },
      "TeamResponse": {
        "title": "TeamResponse",
        "description": "Team without an expanded list of users.\n\nUsed to avoid circular nesting of `Team.users` -> `User.teams`.",
        "required": [
          "name",
          "organization_id",
          "id",
          "created_at",
          "updated_at",
          "users"
        ],
        "type": "object",
        "properties": {
          "description": {
            "title": "Team description",
            "type": "string"
          },
          "name": {
            "title": "Team name",
            "type": "string"
          },
          "organization_id": {
            "title": "Organization ID",
            "description": "String ID of organization that this team belongs to. Starts with `org_`.",
            "type": "string"
          },
          "id": {
            "title": "Team ID",
            "description": "String ID of team. Starts with `tm_`.",
            "type": "string"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          },
          "updated_at": {
            "title": "Updated At",
            "type": "string",
            "format": "date-time"
          },
          "users": {
            "title": "Users",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TeamUserResponse"
            }
          }
        }
      },
      "TeamUserResponse": {
        "title": "TeamUserResponse",
        "required": ["id", "email_address", "verified", "role"],
        "type": "object",
        "properties": {
          "id": {
            "title": "User ID",
            "description": "String ID of user. Starts with `usr_`.",
            "type": "string"
          },
          "email_address": {
            "title": "Email address",
            "description": "The user's email address.",
            "type": "string"
          },
          "full_name": {
            "title": "Full name",
            "description": "The user's full name.",
            "type": "string"
          },
          "verified": {
            "title": "Verified",
            "description": "Whether the user has verified their email address.",
            "type": "boolean"
          },
          "feature_flags": {
            "title": "Feature Flags",
            "type": "object",
            "additionalProperties": {
              "type": "boolean"
            }
          },
          "role": {
            "$ref": "#/components/schemas/UserTeamRole"
          }
        }
      },
      "ToolResultResponse": {
        "title": "ToolResultResponse",
        "description": "A result from a tool used to populate the prompt template",
        "required": ["id", "name", "signature", "result"],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "type": "string"
          },
          "signature": {
            "title": "Signature",
            "type": "string"
          },
          "result": {
            "title": "Result",
            "type": "string"
          }
        }
      },
      "ToolSpecResponse": {
        "title": "ToolSpecResponse",
        "required": ["name", "description", "func_name", "signature"],
        "type": "object",
        "properties": {
          "description": {
            "title": "Description",
            "description": "Description of the tool - acts as a specification to agents for how to use the tool ",
            "type": "string"
          },
          "name": {
            "title": "Name",
            "description": "Unique name for the tool",
            "type": "string"
          },
          "setup_spec": {
            "title": "Setup arguments spec",
            "description": "Field definitions for the setup (i.e. init) arguments that the tool needs - e.g api_key",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/SetupAndRunSpec"
            }
          },
          "run_spec": {
            "title": "Run arguments spec",
            "description": "Field definitions for the run arguments the tool needs - e.g query",
            "type": "array",
            "items": {
              "type": "object"
            }
          },
          "func_name": {
            "title": "Name of callable",
            "description": "Unique name to use when running tool.",
            "type": "string"
          },
          "signature": {
            "title": "Signature",
            "description": "The function signature of the tool when being called.",
            "type": "string"
          }
        }
      },
      "UpdateExperimentRequest": {
        "title": "UpdateExperimentRequest",
        "type": "object",
        "properties": {
          "name": {
            "title": "Experiment name",
            "description": "Name of experiment.",
            "type": "string"
          },
          "positive_labels": {
            "title": "Positive labels",
            "description": "Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            }
          },
          "config_ids_to_register": {
            "title": "Model config IDs to register",
            "description": "Model configs to add to this experiment.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "config_ids_to_deregister": {
            "title": "Model config IDs to deregister",
            "description": "Model configs in this experiment to be deactivated.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "UpdateMetricRequest": {
        "title": "UpdateMetricRequest",
        "type": "object",
        "properties": {
          "description": {
            "title": "Metric description",
            "description": "A description of what the metric measures.",
            "type": "string"
          },
          "name": {
            "title": "Metric name",
            "description": "The name of the metric.",
            "type": "string"
          },
          "code": {
            "title": "Metric code",
            "description": "Python code used to calculate a metric value on each logged datapoint.",
            "type": "string"
          },
          "active": {
            "title": "Metric active flag",
            "description": "If enabled, the metric is calculated for every logged datapoint.",
            "type": "boolean"
          }
        }
      },
      "UpdateOrgToolRequest": {
        "title": "UpdateOrgToolRequest",
        "type": "object",
        "properties": {
          "description": {
            "title": "Tool description",
            "description": "Organization's description for the tool. If not provided, the spec description will be used",
            "type": "string"
          },
          "name": {
            "title": "Tool name",
            "description": "Organizations name for the tool. If not provided, the spec name will be used",
            "type": "string"
          },
          "func_name": {
            "title": "Function name",
            "description": "Name of the function as it called",
            "type": "string"
          },
          "setup_values": {
            "title": "Tool setup values",
            "description": "Any setup values needed to set the tool as active - retrieve what setup values are required from GET on v3/tools",
            "type": "object"
          },
          "status": {
            "title": "Tool status",
            "description": "Whether the tool has been set up by the org.",
            "allOf": [
              {
                "$ref": "#/components/schemas/OrganizationToolStatus"
              }
            ]
          }
        }
      },
      "UpdateOrganizationRequest": {
        "title": "UpdateOrganizationRequest",
        "type": "object",
        "properties": {
          "name": {
            "title": "Organization name",
            "type": "string"
          },
          "slug": {
            "title": "Organization unique slug",
            "description": "A unique slug that will be used for the organization. Only accepts letters, numbers, and hyphens.",
            "type": "string"
          }
        }
      },
      "UpdateProjectRequest": {
        "title": "UpdateProjectRequest",
        "type": "object",
        "properties": {
          "active_experiment_id": {
            "title": "Active experiment ID",
            "description": "ID for an experiment to set as the project's active deployment. Starts with 'exp_'. At most one of 'active_experiment_id' and 'active_model_config_id' can be set.",
            "type": "string"
          },
          "active_model_config_id": {
            "title": "Active model configuration ID",
            "description": "ID for a model configuration to set as the project's active deployment. Starts with 'config_'. At most one of 'active_experiment_id' and 'active_model_config_id' can be set.",
            "type": "string"
          },
          "positive_labels": {
            "title": "List of feedback labels to consider as positive actions",
            "description": "The full list of labels to treat as positive user feedback.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PositiveLabel"
            }
          }
        }
      },
      "UpdateUserOrganizationRole": {
        "title": "UpdateUserOrganizationRole",
        "required": ["role"],
        "type": "object",
        "properties": {
          "role": {
            "title": "User role",
            "description": "Role assigned to the user.",
            "allOf": [
              {
                "$ref": "#/components/schemas/UserOrganizationRole"
              }
            ]
          }
        }
      },
      "UsageReportResponse": {
        "title": "UsageReportResponse",
        "description": "Usage reports sent to payments provider over time.",
        "required": [
          "id",
          "unit",
          "units_used",
          "usage_from",
          "usage_to",
          "created_at"
        ],
        "type": "object",
        "properties": {
          "id": {
            "title": "Id",
            "type": "string"
          },
          "unit": {
            "title": "Unit",
            "type": "string"
          },
          "units_used": {
            "title": "Units Used",
            "type": "integer"
          },
          "usage_from": {
            "title": "Usage From",
            "type": "string",
            "format": "date-time"
          },
          "usage_to": {
            "title": "Usage To",
            "type": "string",
            "format": "date-time"
          },
          "created_at": {
            "title": "Created At",
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "UserOrganizationRole": {
        "title": "UserOrganizationRole",
        "description": "An enumeration.",
        "enum": ["admin", "member"],
        "type": "string"
      },
      "UserResponse": {
        "title": "UserResponse",
        "required": ["id", "email_address", "verified"],
        "type": "object",
        "properties": {
          "id": {
            "title": "User ID",
            "description": "String ID of user. Starts with `usr_`.",
            "type": "string"
          },
          "email_address": {
            "title": "Email address",
            "description": "The user's email address.",
            "type": "string"
          },
          "full_name": {
            "title": "Full name",
            "description": "The user's full name.",
            "type": "string"
          },
          "verified": {
            "title": "Verified",
            "description": "Whether the user has verified their email address.",
            "type": "boolean"
          },
          "feature_flags": {
            "title": "Feature Flags",
            "type": "object",
            "additionalProperties": {
              "type": "boolean"
            }
          }
        }
      },
      "UserTeamRole": {
        "title": "UserTeamRole",
        "description": "An enumeration.",
        "enum": ["admin", "member"],
        "type": "string"
      },
      "ValidationError": {
        "title": "ValidationError",
        "required": ["loc", "msg", "type"],
        "type": "object",
        "properties": {
          "loc": {
            "title": "Location",
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            }
          },
          "msg": {
            "title": "Message",
            "type": "string"
          },
          "type": {
            "title": "Error Type",
            "type": "string"
          }
        }
      },
      "UpdateFeedbackTypesRequest": {
        "title": "Feedback Types",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/FeedbackTypeRequest"
        }
      },
      "GenerateRequest": {
        "title": "Request",
        "anyOf": [
          {
            "$ref": "#/components/schemas/RawGenerate"
          },
          {
            "$ref": "#/components/schemas/ModelConfigGenerate"
          },
          {
            "$ref": "#/components/schemas/ExperimentGenerate"
          },
          {
            "$ref": "#/components/schemas/ProjectGenerate"
          }
        ]
      },
      "LogRequestBody": {
        "title": "Log Request",
        "anyOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogRequest"
            }
          },
          {
            "$ref": "#/components/schemas/LogRequest"
          }
        ]
      },
      "SubmitRequest": {
        "title": "Feedback Request",
        "anyOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackRequest"
            }
          },
          {
            "$ref": "#/components/schemas/FeedbackRequest"
          }
        ]
      },
      "GetModelConfigsResponse": {
        "title": "Response Get Project Model Configs Projects  Id  Model Configs Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ProjectModelConfigResponse"
        }
      },
      "UpdateFeedbackTypesResponse": {
        "type": "object",
        "properties": {},
        "example": {}
      },
      "Log200Response": {
        "title": "Response Log Logs Post",
        "anyOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/CreateLogResponse"
            }
          },
          {
            "$ref": "#/components/schemas/CreateLogResponse"
          }
        ]
      },
      "SubmitResponse": {
        "title": "Response Feedback Feedback Post",
        "anyOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FeedbackResponse"
            }
          },
          {
            "$ref": "#/components/schemas/FeedbackResponse"
          }
        ]
      },
      "ListResponse": {
        "title": "Response Get Project Experiments Projects  Project Id  Experiments Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ExperimentResponse"
        }
      },
      "List200Response": {
        "title": "Response Get Metrics Projects  Project Id  Metrics Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/MetricResponse"
        }
      },
      "GetSubscriptionsResponse": {
        "title": "Response Get Organization Subscriptions Organizations  Id  Subscriptions Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/SubscriptionResponse"
        }
      },
      "GetApiKeysResponse": {
        "title": "Response Get Api Keys Organizations  Id  Api Keys Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ApiKeyResponse"
        }
      },
      "GetToolsResponse": {
        "title": "Response Get Organization Tools Organizations  Id  Tools Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/OrganizationToolResponse"
        }
      },
      "GetSpecsResponse": {
        "title": "Response Get Tool Specs Tools Get",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/ToolSpecResponse"
        }
      }
    },
    "securitySchemes": {
      "APIKeyHeader": {
        "description": "The Humanloop API uses API keys for authentication. Visit your \n[User Settings](https://app.humanloop.com/llama/settings) page to retrieve the\nAPI key you'll use in your requests.\n\nThis key allows full access and control over your projects, so keep this secret\nand take care to not expose it in any client-side code.\n\nTo use your API key, include it under the `X-API-KEY` header in your HTTP request.\n\n```bash\ncurl https://api.humanloop.com/v3/projects -H 'X-API-KEY: YOUR_API_KEY'\n```\n\nIf you're using the Python SDK, initialize the client with your API key before\nusing other SDK methods:\n\n```python\nhl.init(api_key=\"YOUR_API_KEY\")\n```",
        "type": "apiKey",
        "in": "header",
        "name": "X-API-KEY"
      }
    }
  },
  "x-readme": {
    "samples-languages": ["python", "javascript", "curl"]
  }
}
